From 6d0efa8701d1f9e296a9c12a7eddafdd3a2ff81f Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Tue, 5 Sep 2023 17:27:17 -0400
Subject: [PATCH 208/834] nir/legalize_16bit_sampler_srcs: Use instr_pass

Fixes the pass with multiple functions.

Signed-off-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Reviewed-by: Karol Herbst <kherbst@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/25625>
---
 src/compiler/nir/nir_lower_mediump.c | 125 +++++++++++++--------------
 1 file changed, 59 insertions(+), 66 deletions(-)

diff --git a/src/compiler/nir/nir_lower_mediump.c b/src/compiler/nir/nir_lower_mediump.c
index 01377f7ddf7..ff4f5171618 100644
--- a/src/compiler/nir/nir_lower_mediump.c
+++ b/src/compiler/nir/nir_lower_mediump.c
@@ -653,87 +653,80 @@ is_i32_to_i16_conversion(nir_instr *instr)
  * coordinates and the type of the texture bias must be 32-bit, there
  * will be 2 constraints describing that.
  */
-bool
-nir_legalize_16bit_sampler_srcs(nir_shader *nir,
-                                nir_tex_src_type_constraints constraints)
+static bool
+legalize_16bit_sampler_srcs(nir_builder *b, nir_instr *instr, void *data)
 {
-   bool changed = false;
-   nir_function_impl *impl = nir_shader_get_entrypoint(nir);
-   assert(impl);
-
-   nir_builder b = nir_builder_create(impl);
+   bool progress = false;
+   nir_tex_src_type_constraint *constraints = data;
 
-   nir_foreach_block_safe(block, impl) {
-      nir_foreach_instr_safe(instr, block) {
-         if (instr->type != nir_instr_type_tex)
-            continue;
+   if (instr->type != nir_instr_type_tex)
+      return false;
 
-         nir_tex_instr *tex = nir_instr_as_tex(instr);
-         int8_t map[nir_num_tex_src_types];
-         memset(map, -1, sizeof(map));
+   nir_tex_instr *tex = nir_instr_as_tex(instr);
+   int8_t map[nir_num_tex_src_types];
+   memset(map, -1, sizeof(map));
 
-         /* Create a mapping from src_type to src[i]. */
-         for (unsigned i = 0; i < tex->num_srcs; i++)
-            map[tex->src[i].src_type] = i;
+   /* Create a mapping from src_type to src[i]. */
+   for (unsigned i = 0; i < tex->num_srcs; i++)
+      map[tex->src[i].src_type] = i;
 
-         /* Legalize src types. */
-         for (unsigned i = 0; i < tex->num_srcs; i++) {
-            nir_tex_src_type_constraint c = constraints[tex->src[i].src_type];
+   /* Legalize src types. */
+   for (unsigned i = 0; i < tex->num_srcs; i++) {
+      nir_tex_src_type_constraint c = constraints[tex->src[i].src_type];
 
-            if (!c.legalize_type)
-               continue;
+      if (!c.legalize_type)
+         continue;
 
-            /* Determine the required bit size for the src. */
-            unsigned bit_size;
-            if (c.bit_size) {
-               bit_size = c.bit_size;
-            } else {
-               if (map[c.match_src] == -1)
-                  continue; /* e.g. txs */
+      /* Determine the required bit size for the src. */
+      unsigned bit_size;
+      if (c.bit_size) {
+         bit_size = c.bit_size;
+      } else {
+         if (map[c.match_src] == -1)
+            continue; /* e.g. txs */
 
-               bit_size = tex->src[map[c.match_src]].src.ssa->bit_size;
-            }
+         bit_size = tex->src[map[c.match_src]].src.ssa->bit_size;
+      }
 
-            /* Check if the type is legal. */
-            if (bit_size == tex->src[i].src.ssa->bit_size)
-               continue;
+      /* Check if the type is legal. */
+      if (bit_size == tex->src[i].src.ssa->bit_size)
+         continue;
 
-            /* Fix the bit size. */
-            bool is_sint = nir_tex_instr_src_type(tex, i) == nir_type_int;
-            bool is_uint = nir_tex_instr_src_type(tex, i) == nir_type_uint;
-            nir_def *(*convert)(nir_builder *, nir_def *);
+      /* Fix the bit size. */
+      bool is_sint = nir_tex_instr_src_type(tex, i) == nir_type_int;
+      bool is_uint = nir_tex_instr_src_type(tex, i) == nir_type_uint;
+      nir_def *(*convert)(nir_builder *, nir_def *);
 
-            switch (bit_size) {
-            case 16:
-               convert = is_sint ? nir_i2i16 : is_uint ? nir_u2u16
-                                                       : nir_f2f16;
-               break;
-            case 32:
-               convert = is_sint ? nir_i2i32 : is_uint ? nir_u2u32
-                                                       : nir_f2f32;
-               break;
-            default:
-               assert(!"unexpected bit size");
-               continue;
-            }
-
-            b.cursor = nir_before_instr(&tex->instr);
-            nir_def *conv =
-               convert(&b, tex->src[i].src.ssa);
-            nir_src_rewrite(&tex->src[i].src, conv);
-            changed = true;
-         }
+      switch (bit_size) {
+      case 16:
+         convert = is_sint ? nir_i2i16 : is_uint ? nir_u2u16
+                                                 : nir_f2f16;
+         break;
+      case 32:
+         convert = is_sint ? nir_i2i32 : is_uint ? nir_u2u32
+                                                 : nir_f2f32;
+         break;
+      default:
+         assert(!"unexpected bit size");
+         continue;
       }
-   }
 
-   if (changed) {
-      nir_metadata_preserve(impl, nir_metadata_dominance |
-                                     nir_metadata_block_index);
-   } else {
-      nir_metadata_preserve(impl, nir_metadata_all);
+      b->cursor = nir_before_instr(&tex->instr);
+      nir_src_rewrite(&tex->src[i].src, convert(b, tex->src[i].src.ssa));
+      progress = true;
    }
 
-   return changed;
+   return progress;
+}
+
+bool
+nir_legalize_16bit_sampler_srcs(nir_shader *nir,
+                                nir_tex_src_type_constraints constraints)
+{
+   return nir_shader_instructions_pass(nir, legalize_16bit_sampler_srcs,
+                                       nir_metadata_dominance |
+                                          nir_metadata_block_index,
+                                       constraints);
 }
 
 static bool
-- 
2.42.0

