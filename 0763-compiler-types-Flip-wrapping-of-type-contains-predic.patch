From 3bf500af7b259018dac00c0cddb0783c0eaf8655 Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Sat, 2 Sep 2023 10:25:37 -0700
Subject: [PATCH 763/834] compiler/types: Flip wrapping of "type contains?"
 predicate functions

Reviewed-by: Kenneth Graunke <kenneth@whitecape.org>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/25129>
---
 src/compiler/glsl_types.cpp    | 85 ++++++++++++++++++----------------
 src/compiler/glsl_types_impl.h | 13 +++---
 src/compiler/nir_types.cpp     | 36 --------------
 3 files changed, 53 insertions(+), 81 deletions(-)

diff --git a/src/compiler/glsl_types.cpp b/src/compiler/glsl_types.cpp
index 319acb1f2ae..44eee5fa23e 100644
--- a/src/compiler/glsl_types.cpp
+++ b/src/compiler/glsl_types.cpp
@@ -207,67 +207,68 @@ glsl_type::contains_array() const
    }
 }
 
-bool
-glsl_type::contains_integer() const
-{
-   if (this->is_array()) {
-      return this->fields.array->contains_integer();
-   } else if (this->is_struct() || this->is_interface()) {
-      for (unsigned int i = 0; i < this->length; i++) {
-         if (this->fields.structure[i].type->contains_integer())
+extern "C" bool
+glsl_contains_integer(const struct glsl_type *t)
+{
+   if (t->is_array()) {
+      return t->fields.array->contains_integer();
+   } else if (t->is_struct() || t->is_interface()) {
+      for (unsigned int i = 0; i < t->length; i++) {
+         if (t->fields.structure[i].type->contains_integer())
             return true;
       }
       return false;
    } else {
-      return this->is_integer();
+      return t->is_integer();
    }
 }
 
-bool
-glsl_type::contains_double() const
+extern "C" bool
+glsl_contains_double(const struct glsl_type *t)
 {
-   if (this->is_array()) {
-      return this->fields.array->contains_double();
-   } else if (this->is_struct() || this->is_interface()) {
-      for (unsigned int i = 0; i < this->length; i++) {
-         if (this->fields.structure[i].type->contains_double())
+   if (t->is_array()) {
+      return t->fields.array->contains_double();
+   } else if (t->is_struct() || t->is_interface()) {
+      for (unsigned int i = 0; i < t->length; i++) {
+         if (t->fields.structure[i].type->contains_double())
             return true;
       }
       return false;
    } else {
-      return this->is_double();
+      return t->is_double();
    }
 }
 
-bool
-glsl_type::contains_64bit() const
+extern "C" bool
+glsl_type_contains_64bit(const struct glsl_type *t)
 {
-   if (this->is_array()) {
-      return this->fields.array->contains_64bit();
-   } else if (this->is_struct() || this->is_interface()) {
-      for (unsigned int i = 0; i < this->length; i++) {
-         if (this->fields.structure[i].type->contains_64bit())
+   if (t->is_array()) {
+      return t->fields.array->contains_64bit();
+   } else if (t->is_struct() || t->is_interface()) {
+      for (unsigned int i = 0; i < t->length; i++) {
+         if (t->fields.structure[i].type->contains_64bit())
             return true;
       }
       return false;
    } else {
-      return this->is_64bit();
+      return t->is_64bit();
    }
 }
 
-bool
-glsl_type::contains_opaque() const {
-   switch (base_type) {
+extern "C" bool
+glsl_contains_opaque(const struct glsl_type *t)
+{
+   switch (t->base_type) {
    case GLSL_TYPE_SAMPLER:
    case GLSL_TYPE_IMAGE:
    case GLSL_TYPE_ATOMIC_UINT:
       return true;
    case GLSL_TYPE_ARRAY:
-      return fields.array->contains_opaque();
+      return t->fields.array->contains_opaque();
    case GLSL_TYPE_STRUCT:
    case GLSL_TYPE_INTERFACE:
-      for (unsigned int i = 0; i < length; i++) {
-         if (fields.structure[i].type->contains_opaque())
+      for (unsigned int i = 0; i < t->length; i++) {
+         if (t->fields.structure[i].type->contains_opaque())
             return true;
       }
       return false;
@@ -292,19 +293,19 @@ glsl_type::contains_subroutine() const
    }
 }
 
-bool
-glsl_type::contains_image() const
+extern "C" bool
+glsl_type_contains_image(const struct glsl_type *t)
 {
-   if (this->is_array()) {
-      return this->fields.array->contains_image();
-   } else if (this->is_struct() || this->is_interface()) {
-      for (unsigned int i = 0; i < this->length; i++) {
-         if (this->fields.structure[i].type->contains_image())
+   if (t->is_array()) {
+      return t->fields.array->contains_image();
+   } else if (t->is_struct() || t->is_interface()) {
+      for (unsigned int i = 0; i < t->length; i++) {
+         if (t->fields.structure[i].type->contains_image())
             return true;
       }
       return false;
    } else {
-      return this->is_image();
+      return t->is_image();
    }
 }
 
@@ -3434,4 +3435,10 @@ glsl_type_is_leaf(const struct glsl_type *t)
    }
 }
 
+bool
+glsl_contains_atomic(const struct glsl_type *t)
+{
+   return t->atomic_size() > 0;
+}
+
 }
diff --git a/src/compiler/glsl_types_impl.h b/src/compiler/glsl_types_impl.h
index 405a644754c..d7358bb526f 100644
--- a/src/compiler/glsl_types_impl.h
+++ b/src/compiler/glsl_types_impl.h
@@ -38,6 +38,13 @@ inline bool glsl_type::is_16bit() const { return glsl_type_is_16bit(this); }
 inline bool glsl_type::is_32bit() const { return glsl_type_is_32bit(this); }
 inline bool glsl_type::is_64bit() const { return glsl_type_is_64bit(this); }
 
+inline bool glsl_type::contains_64bit() const { return glsl_type_contains_64bit(this); }
+inline bool glsl_type::contains_image() const { return glsl_type_contains_image(this); }
+inline bool glsl_type::contains_atomic() const { return glsl_contains_atomic(this); }
+inline bool glsl_type::contains_opaque() const { return glsl_contains_opaque(this); }
+inline bool glsl_type::contains_double() const { return glsl_contains_double(this); }
+inline bool glsl_type::contains_integer() const { return glsl_contains_integer(this); }
+
 inline unsigned
 glsl_type::components() const
 {
@@ -203,12 +210,6 @@ glsl_type::atomic_size() const
       return 0;
 }
 
-inline bool
-glsl_type::contains_atomic() const
-{
-   return atomic_size() > 0;
-}
-
 inline const glsl_type *
 glsl_type::row_type() const
 {
diff --git a/src/compiler/nir_types.cpp b/src/compiler/nir_types.cpp
index e694c3e0038..01f2ac7a326 100644
--- a/src/compiler/nir_types.cpp
+++ b/src/compiler/nir_types.cpp
@@ -240,30 +240,6 @@ glsl_get_struct_location_offset(const struct glsl_type *type,
    return type->struct_location_offset(length);
 }
 
-bool
-glsl_type_contains_64bit(const struct glsl_type *type)
-{
-   return type->contains_64bit();
-}
-
-bool
-glsl_type_contains_image(const struct glsl_type *type)
-{
-   return type->contains_image();
-}
-
-bool
-glsl_contains_double(const struct glsl_type *type)
-{
-   return type->contains_double();
-}
-
-bool
-glsl_contains_integer(const struct glsl_type *type)
-{
-   return type->contains_integer();
-}
-
 bool
 glsl_record_compare(const struct glsl_type *a, const struct glsl_type *b,
                     bool match_name, bool match_locations, bool match_precision)
@@ -601,18 +577,6 @@ glsl_atomic_size(const struct glsl_type *type)
    return type->atomic_size();
 }
 
-bool
-glsl_contains_atomic(const struct glsl_type *type)
-{
-   return type->contains_atomic();
-}
-
-bool
-glsl_contains_opaque(const struct glsl_type *type)
-{
-   return type->contains_opaque();
-}
-
 int
 glsl_get_cl_size(const struct glsl_type *type)
 {
-- 
2.42.0

