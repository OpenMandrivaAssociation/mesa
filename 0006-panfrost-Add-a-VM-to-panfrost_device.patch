From 370dc2d654d0db58f0dc69f8b2c1a32db1fce265 Mon Sep 17 00:00:00 2001
From: Boris Brezillon <boris.brezillon@collabora.com>
Date: Mon, 20 Nov 2023 17:46:15 +0100
Subject: [PATCH 06/29] panfrost: Add a VM to panfrost_device

The current code assumes the logical device comes with a VM, so let's
explicitly create this default VM so we can map BOs with the kmod API.

Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
---
 src/panfrost/lib/pan_device.h |  3 +++
 src/panfrost/lib/pan_props.c  | 23 +++++++++++++++++++++++
 2 files changed, 26 insertions(+)

diff --git a/src/panfrost/lib/pan_device.h b/src/panfrost/lib/pan_device.h
index 5df6d6db189..bbf94dc305d 100644
--- a/src/panfrost/lib/pan_device.h
+++ b/src/panfrost/lib/pan_device.h
@@ -137,6 +137,9 @@ struct panfrost_device {
 
       /* Cached pan_kmod_dev_props properties queried at device create time. */
       struct pan_kmod_dev_props props;
+
+      /* VM attached to this device. */
+      struct pan_kmod_vm *vm;
    } kmod;
 
    /* For pandecode */
diff --git a/src/panfrost/lib/pan_props.c b/src/panfrost/lib/pan_props.c
index f155031e5cd..a3675feb095 100644
--- a/src/panfrost/lib/pan_props.c
+++ b/src/panfrost/lib/pan_props.c
@@ -191,6 +191,19 @@ panfrost_query_optimal_tib_size(const struct panfrost_device *dev)
    return dev->model->tilebuffer_size / 2;
 }
 
+/* Always reserve the lower 32MB. */
+#define PANFROST_VA_START 0x2000000
+
+static void
+panfrost_query_gpu_va_range(const struct panfrost_device *dev,
+                            uint64_t *va_start, uint64_t *va_size)
+{
+   uint64_t va_bits = dev->kmod.props.mmu_features & 0xff;
+
+   *va_start = PANFROST_VA_START;
+   *va_size = (1ull << va_bits) - PANFROST_VA_START;
+}
+
 void
 panfrost_open_device(void *memctx, int fd, struct panfrost_device *dev)
 {
@@ -211,6 +224,13 @@ panfrost_open_device(void *memctx, int fd, struct panfrost_device *dev)
    if (!dev->model)
       goto err_free_kmod_dev;
 
+   uint64_t user_va_start, user_va_range;
+
+   panfrost_query_gpu_va_range(dev, &user_va_start, &user_va_range);
+   dev->kmod.vm = pan_kmod_vm_create(dev->kmod.dev, PAN_KMOD_VM_FLAG_AUTO_VA,
+                                     user_va_start, user_va_range);
+   if (!dev->kmod.vm)
+      goto err_free_kmod_dev;
 
    dev->core_count = panfrost_query_core_count(dev, &dev->core_id_range);
    dev->thread_tls_alloc = panfrost_query_thread_tls_alloc(dev, dev->arch);
@@ -275,6 +295,9 @@ panfrost_close_device(struct panfrost_device *dev)
       util_sparse_array_finish(&dev->bo_map);
    }
 
+   if (dev->kmod.vm)
+      pan_kmod_vm_destroy(dev->kmod.vm);
+
    if (dev->kmod.dev)
       pan_kmod_dev_destroy(dev->kmod.dev);
 }
-- 
2.43.0

