From a92d536cd7a6a27ba9dba538ace8baf0dfc76f2f Mon Sep 17 00:00:00 2001
From: Matt Coster <matt.coster@imgtec.com>
Date: Tue, 26 Sep 2023 13:48:40 +0100
Subject: [PATCH 150/834] pvr: Switch to common pipeline cache implementation

We don't currently make use of pipeline caching, but the common
implementation handles the boilerplate we had in pvr_pipeline_cache.c
for us.

Signed-off-by: Matt Coster <matt.coster@imgtec.com>
Reviewed-by: Frank Binns <frank.binns@imgtec.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/25422>
---
 src/imagination/vulkan/meson.build          |   1 -
 src/imagination/vulkan/pvr_pipeline.c       |  29 ++--
 src/imagination/vulkan/pvr_pipeline_cache.c | 155 --------------------
 src/imagination/vulkan/pvr_private.h        |  10 --
 4 files changed, 15 insertions(+), 180 deletions(-)
 delete mode 100644 src/imagination/vulkan/pvr_pipeline_cache.c

diff --git a/src/imagination/vulkan/meson.build b/src/imagination/vulkan/meson.build
index b3c88065d96..d931cb9eb68 100644
--- a/src/imagination/vulkan/meson.build
+++ b/src/imagination/vulkan/meson.build
@@ -58,7 +58,6 @@ pvr_files = files(
   'pvr_job_transfer.c',
   'pvr_pass.c',
   'pvr_pipeline.c',
-  'pvr_pipeline_cache.c',
   'pvr_transfer_frag_store.c',
   'pvr_query.c',
   'pvr_query_compute.c',
diff --git a/src/imagination/vulkan/pvr_pipeline.c b/src/imagination/vulkan/pvr_pipeline.c
index bd9cc0f0cd0..0b88f87535b 100644
--- a/src/imagination/vulkan/pvr_pipeline.c
+++ b/src/imagination/vulkan/pvr_pipeline.c
@@ -53,6 +53,7 @@
 #include "vk_graphics_state.h"
 #include "vk_log.h"
 #include "vk_object.h"
+#include "vk_pipeline_cache.h"
 #include "vk_render_pass.h"
 #include "vk_util.h"
 
@@ -1212,7 +1213,7 @@ pvr_pipeline_alloc_shareds(const struct pvr_device *device,
 /* Compiles and uploads shaders and PDS programs. */
 static VkResult pvr_compute_pipeline_compile(
    struct pvr_device *const device,
-   struct pvr_pipeline_cache *pipeline_cache,
+   struct vk_pipeline_cache *cache,
    const VkComputePipelineCreateInfo *pCreateInfo,
    const VkAllocationCallbacks *const allocator,
    struct pvr_compute_pipeline *const compute_pipeline)
@@ -1347,7 +1348,7 @@ err_free_shader:
 
 static VkResult
 pvr_compute_pipeline_init(struct pvr_device *device,
-                          struct pvr_pipeline_cache *pipeline_cache,
+                          struct vk_pipeline_cache *cache,
                           const VkComputePipelineCreateInfo *pCreateInfo,
                           const VkAllocationCallbacks *allocator,
                           struct pvr_compute_pipeline *compute_pipeline)
@@ -1362,7 +1363,7 @@ pvr_compute_pipeline_init(struct pvr_device *device,
       pvr_pipeline_layout_from_handle(pCreateInfo->layout);
 
    result = pvr_compute_pipeline_compile(device,
-                                         pipeline_cache,
+                                         cache,
                                          pCreateInfo,
                                          allocator,
                                          compute_pipeline);
@@ -1376,7 +1377,7 @@ pvr_compute_pipeline_init(struct pvr_device *device,
 
 static VkResult
 pvr_compute_pipeline_create(struct pvr_device *device,
-                            struct pvr_pipeline_cache *pipeline_cache,
+                            struct vk_pipeline_cache *cache,
                             const VkComputePipelineCreateInfo *pCreateInfo,
                             const VkAllocationCallbacks *allocator,
                             VkPipeline *const pipeline_out)
@@ -1394,7 +1395,7 @@ pvr_compute_pipeline_create(struct pvr_device *device,
 
    /* Compiles and uploads shaders and PDS programs. */
    result = pvr_compute_pipeline_init(device,
-                                      pipeline_cache,
+                                      cache,
                                       pCreateInfo,
                                       allocator,
                                       compute_pipeline);
@@ -1442,14 +1443,14 @@ pvr_CreateComputePipelines(VkDevice _device,
                            const VkAllocationCallbacks *pAllocator,
                            VkPipeline *pPipelines)
 {
-   PVR_FROM_HANDLE(pvr_pipeline_cache, pipeline_cache, pipelineCache);
+   VK_FROM_HANDLE(vk_pipeline_cache, cache, pipelineCache);
    PVR_FROM_HANDLE(pvr_device, device, _device);
    VkResult result = VK_SUCCESS;
 
    for (uint32_t i = 0; i < createInfoCount; i++) {
       const VkResult local_result =
          pvr_compute_pipeline_create(device,
-                                     pipeline_cache,
+                                     cache,
                                      &pCreateInfos[i],
                                      pAllocator,
                                      &pPipelines[i]);
@@ -1895,7 +1896,7 @@ static void pvr_graphics_pipeline_alloc_vertex_special_vars(
 /* Compiles and uploads shaders and PDS programs. */
 static VkResult
 pvr_graphics_pipeline_compile(struct pvr_device *const device,
-                              struct pvr_pipeline_cache *pipeline_cache,
+                              struct vk_pipeline_cache *cache,
                               const VkGraphicsPipelineCreateInfo *pCreateInfo,
                               const VkAllocationCallbacks *const allocator,
                               struct pvr_graphics_pipeline *const gfx_pipeline)
@@ -2277,7 +2278,7 @@ pvr_create_renderpass_state(const VkGraphicsPipelineCreateInfo *const info)
 
 static VkResult
 pvr_graphics_pipeline_init(struct pvr_device *device,
-                           struct pvr_pipeline_cache *pipeline_cache,
+                           struct vk_pipeline_cache *cache,
                            const VkGraphicsPipelineCreateInfo *pCreateInfo,
                            const VkAllocationCallbacks *allocator,
                            struct pvr_graphics_pipeline *gfx_pipeline)
@@ -2349,7 +2350,7 @@ pvr_graphics_pipeline_init(struct pvr_device *device,
 
    /* Compiles and uploads shaders and PDS programs. */
    result = pvr_graphics_pipeline_compile(device,
-                                          pipeline_cache,
+                                          cache,
                                           pCreateInfo,
                                           allocator,
                                           gfx_pipeline);
@@ -2367,7 +2368,7 @@ err_pipeline_finish:
 /* If allocator == NULL, the internal one will be used. */
 static VkResult
 pvr_graphics_pipeline_create(struct pvr_device *device,
-                             struct pvr_pipeline_cache *pipeline_cache,
+                             struct vk_pipeline_cache *cache,
                              const VkGraphicsPipelineCreateInfo *pCreateInfo,
                              const VkAllocationCallbacks *allocator,
                              VkPipeline *const pipeline_out)
@@ -2385,7 +2386,7 @@ pvr_graphics_pipeline_create(struct pvr_device *device,
 
    /* Compiles and uploads shaders and PDS programs too. */
    result = pvr_graphics_pipeline_init(device,
-                                       pipeline_cache,
+                                       cache,
                                        pCreateInfo,
                                        allocator,
                                        gfx_pipeline);
@@ -2407,14 +2408,14 @@ pvr_CreateGraphicsPipelines(VkDevice _device,
                             const VkAllocationCallbacks *pAllocator,
                             VkPipeline *pPipelines)
 {
-   PVR_FROM_HANDLE(pvr_pipeline_cache, pipeline_cache, pipelineCache);
+   VK_FROM_HANDLE(vk_pipeline_cache, cache, pipelineCache);
    PVR_FROM_HANDLE(pvr_device, device, _device);
    VkResult result = VK_SUCCESS;
 
    for (uint32_t i = 0; i < createInfoCount; i++) {
       const VkResult local_result =
          pvr_graphics_pipeline_create(device,
-                                      pipeline_cache,
+                                      cache,
                                       &pCreateInfos[i],
                                       pAllocator,
                                       &pPipelines[i]);
diff --git a/src/imagination/vulkan/pvr_pipeline_cache.c b/src/imagination/vulkan/pvr_pipeline_cache.c
deleted file mode 100644
index fb203c42678..00000000000
--- a/src/imagination/vulkan/pvr_pipeline_cache.c
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright © 2022 Imagination Technologies Ltd.
- *
- * based in part on anv driver which is:
- * Copyright © 2015 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-#include <string.h>
-
-#include "pvr_device_info.h"
-#include "pvr_private.h"
-#include "util/blob.h"
-#include "vk_log.h"
-#include "vk_object.h"
-#include "vulkan/util/vk_util.h"
-
-static void pvr_pipeline_cache_load(struct pvr_pipeline_cache *cache,
-                                    const void *data,
-                                    size_t size)
-{
-   struct pvr_device *device = cache->device;
-   struct pvr_physical_device *pdevice = device->pdevice;
-   struct vk_pipeline_cache_header header;
-   struct blob_reader blob;
-
-   blob_reader_init(&blob, data, size);
-
-   blob_copy_bytes(&blob, &header, sizeof(header));
-   if (blob.overrun)
-      return;
-
-   if (header.header_size < sizeof(header))
-      return;
-   if (header.header_version != VK_PIPELINE_CACHE_HEADER_VERSION_ONE)
-      return;
-   if (header.vendor_id != VK_VENDOR_ID_IMAGINATION)
-      return;
-   if (header.device_id != pdevice->dev_info.ident.device_id)
-      return;
-   if (memcmp(header.uuid, pdevice->pipeline_cache_uuid, VK_UUID_SIZE) != 0)
-      return;
-
-   /* TODO: There isn't currently any cached data so there's nothing to load
-    * at this point. Once there is something to load then load it now.
-    */
-}
-
-VkResult pvr_CreatePipelineCache(VkDevice _device,
-                                 const VkPipelineCacheCreateInfo *pCreateInfo,
-                                 const VkAllocationCallbacks *pAllocator,
-                                 VkPipelineCache *pPipelineCache)
-{
-   PVR_FROM_HANDLE(pvr_device, device, _device);
-   struct pvr_pipeline_cache *cache;
-
-   assert(pCreateInfo->sType == VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO);
-   assert(pCreateInfo->flags == 0);
-
-   cache = vk_object_alloc(&device->vk,
-                           pAllocator,
-                           sizeof(*cache),
-                           VK_OBJECT_TYPE_PIPELINE_CACHE);
-   if (!cache)
-      return vk_error(device, VK_ERROR_OUT_OF_HOST_MEMORY);
-
-   cache->device = device;
-
-   if (pCreateInfo->initialDataSize > 0) {
-      pvr_pipeline_cache_load(cache,
-                              pCreateInfo->pInitialData,
-                              pCreateInfo->initialDataSize);
-   }
-
-   *pPipelineCache = pvr_pipeline_cache_to_handle(cache);
-
-   return VK_SUCCESS;
-}
-
-void pvr_DestroyPipelineCache(VkDevice _device,
-                              VkPipelineCache _cache,
-                              const VkAllocationCallbacks *pAllocator)
-{
-   PVR_FROM_HANDLE(pvr_device, device, _device);
-   PVR_FROM_HANDLE(pvr_pipeline_cache, cache, _cache);
-
-   if (!cache)
-      return;
-
-   vk_object_free(&device->vk, pAllocator, cache);
-}
-
-VkResult pvr_GetPipelineCacheData(VkDevice _device,
-                                  VkPipelineCache _cache,
-                                  size_t *pDataSize,
-                                  void *pData)
-{
-   PVR_FROM_HANDLE(pvr_device, device, _device);
-   struct pvr_physical_device *pdevice = device->pdevice;
-   struct blob blob;
-
-   if (pData)
-      blob_init_fixed(&blob, pData, *pDataSize);
-   else
-      blob_init_fixed(&blob, NULL, SIZE_MAX);
-
-   struct vk_pipeline_cache_header header = {
-      .header_size = sizeof(struct vk_pipeline_cache_header),
-      .header_version = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
-      .vendor_id = VK_VENDOR_ID_IMAGINATION,
-      .device_id = pdevice->dev_info.ident.device_id,
-   };
-   memcpy(header.uuid, pdevice->pipeline_cache_uuid, VK_UUID_SIZE);
-   blob_write_bytes(&blob, &header, sizeof(header));
-
-   /* TODO: Once there's some data to cache then this should be written to
-    * 'blob'.
-    */
-
-   *pDataSize = blob.size;
-
-   blob_finish(&blob);
-
-   return VK_SUCCESS;
-}
-
-VkResult pvr_MergePipelineCaches(VkDevice _device,
-                                 VkPipelineCache destCache,
-                                 uint32_t srcCacheCount,
-                                 const VkPipelineCache *pSrcCaches)
-{
-   /* TODO: Once there's some data to cache then this will need to be able to
-    * merge caches together.
-    */
-
-   return VK_SUCCESS;
-}
diff --git a/src/imagination/vulkan/pvr_private.h b/src/imagination/vulkan/pvr_private.h
index 4674c8d3fbf..2a452af327f 100644
--- a/src/imagination/vulkan/pvr_private.h
+++ b/src/imagination/vulkan/pvr_private.h
@@ -832,12 +832,6 @@ struct pvr_cmd_buffer {
    struct list_head sub_cmds;
 };
 
-struct pvr_pipeline_cache {
-   struct vk_object_base base;
-
-   struct pvr_device *device;
-};
-
 struct pvr_stage_allocation_descriptor_state {
    struct pvr_pds_upload pds_code;
    /* Since we upload the code segment separately from the data segment
@@ -1483,10 +1477,6 @@ VK_DEFINE_NONDISP_HANDLE_CASTS(pvr_device_memory,
                                VkDeviceMemory,
                                VK_OBJECT_TYPE_DEVICE_MEMORY)
 VK_DEFINE_NONDISP_HANDLE_CASTS(pvr_image, vk.base, VkImage, VK_OBJECT_TYPE_IMAGE)
-VK_DEFINE_NONDISP_HANDLE_CASTS(pvr_pipeline_cache,
-                               base,
-                               VkPipelineCache,
-                               VK_OBJECT_TYPE_PIPELINE_CACHE)
 VK_DEFINE_NONDISP_HANDLE_CASTS(pvr_buffer,
                                vk.base,
                                VkBuffer,
-- 
2.42.0

