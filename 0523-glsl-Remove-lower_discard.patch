From 91da6be8cece1086cc6ab240f7054f4ebd5db2dc Mon Sep 17 00:00:00 2001
From: Emma Anholt <emma@anholt.net>
Date: Thu, 17 Aug 2023 11:23:35 -0700
Subject: [PATCH 523/834] glsl: Remove lower_discard().

Replaced by the new NIR pass.

i915g results:
total instructions in shared programs: 510678 -> 510714 (<.01%)
total temps in shared programs: 30429 -> 30426 (<.01%)

rv370 results:
total instructions in shared programs: 737649 -> 737656 (<.01%)
instructions in affected programs: 82 -> 89 (8.54%)
total temps in shared programs: 112093 -> 112094 (<.01%)
temps in affected programs: 6 -> 7 (16.67%)

Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/24763>
---
 src/compiler/glsl/ir_optimization.h       |   1 -
 src/compiler/glsl/lower_discard.cpp       | 201 ----------------------
 src/compiler/glsl/meson.build             |   1 -
 src/compiler/glsl/test_optpass.cpp        |   2 -
 src/mesa/state_tracker/st_glsl_to_nir.cpp |   5 -
 5 files changed, 210 deletions(-)
 delete mode 100644 src/compiler/glsl/lower_discard.cpp

diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index 0a394d4371f..d10a4327f15 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -57,7 +57,6 @@ bool do_mat_op_to_vec(exec_list *instructions);
 bool do_minmax_prune(exec_list *instructions);
 bool do_tree_grafting(exec_list *instructions);
 bool do_vec_index_to_cond_assign(exec_list *instructions);
-bool lower_discard(exec_list *instructions);
 void lower_discard_flow(exec_list *instructions);
 bool lower_instructions(exec_list *instructions,
                         bool have_dround,
diff --git a/src/compiler/glsl/lower_discard.cpp b/src/compiler/glsl/lower_discard.cpp
deleted file mode 100644
index 203d9e3b960..00000000000
--- a/src/compiler/glsl/lower_discard.cpp
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Copyright Â© 2010 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file lower_discard.cpp
- *
- * This pass moves discards out of if-statements.
- *
- * Case 1: The "then" branch contains a conditional discard:
- * ---------------------------------------------------------
- *
- *    if (cond1) {
- *	 s1;
- *	 discard cond2;
- *	 s2;
- *    } else {
- *	 s3;
- *    }
- *
- * becomes:
- *
- *    temp = false;
- *    if (cond1) {
- *	 s1;
- *	 temp = cond2;
- *	 s2;
- *    } else {
- *	 s3;
- *    }
- *    discard temp;
- *
- * Case 2: The "else" branch contains a conditional discard:
- * ---------------------------------------------------------
- *
- *    if (cond1) {
- *	 s1;
- *    } else {
- *	 s2;
- *	 discard cond2;
- *	 s3;
- *    }
- *
- * becomes:
- *
- *    temp = false;
- *    if (cond1) {
- *	 s1;
- *    } else {
- *	 s2;
- *	 temp = cond2;
- *	 s3;
- *    }
- *    discard temp;
- *
- * Case 3: Both branches contain a conditional discard:
- * ----------------------------------------------------
- *
- *    if (cond1) {
- *	 s1;
- *	 discard cond2;
- *	 s2;
- *    } else {
- *	 s3;
- *	 discard cond3;
- *	 s4;
- *    }
- *
- * becomes:
- *
- *    temp = false;
- *    if (cond1) {
- *	 s1;
- *	 temp = cond2;
- *	 s2;
- *    } else {
- *	 s3;
- *	 temp = cond3;
- *	 s4;
- *    }
- *    discard temp;
- *
- * If there are multiple conditional discards, we need only deal with one of
- * them.  Repeatedly applying this pass will take care of the others.
- *
- * Unconditional discards are treated as having a condition of "true".
- */
-
-#include "compiler/glsl_types.h"
-#include "ir.h"
-
-namespace {
-
-class lower_discard_visitor : public ir_hierarchical_visitor {
-public:
-   lower_discard_visitor()
-   {
-      this->progress = false;
-   }
-
-   ir_visitor_status visit_leave(ir_if *);
-
-   bool progress;
-};
-
-} /* anonymous namespace */
-
-bool
-lower_discard(exec_list *instructions)
-{
-   lower_discard_visitor v;
-
-   visit_list_elements(&v, instructions);
-
-   return v.progress;
-}
-
-
-static ir_discard *
-find_discard(exec_list &instructions)
-{
-   foreach_in_list(ir_instruction, node, &instructions) {
-      ir_discard *ir = node->as_discard();
-      if (ir != NULL)
-	 return ir;
-   }
-   return NULL;
-}
-
-
-static void
-replace_discard(void *mem_ctx, ir_variable *var, ir_discard *ir)
-{
-   ir_rvalue *condition = ir->condition;
-
-   /* For unconditional discards, use "true" as the condition. */
-   if (condition == NULL)
-      condition = new(mem_ctx) ir_constant(true);
-
-   ir_assignment *assignment =
-      new(mem_ctx) ir_assignment(new(mem_ctx) ir_dereference_variable(var),
-                                 condition);
-
-   ir->replace_with(assignment);
-}
-
-
-ir_visitor_status
-lower_discard_visitor::visit_leave(ir_if *ir)
-{
-   ir_discard *then_discard = find_discard(ir->then_instructions);
-   ir_discard *else_discard = find_discard(ir->else_instructions);
-
-   if (then_discard == NULL && else_discard == NULL)
-      return visit_continue;
-
-   void *mem_ctx = ralloc_parent(ir);
-
-   ir_variable *temp = new(mem_ctx) ir_variable(glsl_type::bool_type,
-						"discard_cond_temp",
-						ir_var_temporary);
-   ir_assignment *temp_initializer =
-      new(mem_ctx) ir_assignment(new(mem_ctx) ir_dereference_variable(temp),
-                                 new(mem_ctx) ir_constant(false));
-
-   ir->insert_before(temp);
-   ir->insert_before(temp_initializer);
-
-   if (then_discard != NULL)
-      replace_discard(mem_ctx, temp, then_discard);
-
-   if (else_discard != NULL)
-      replace_discard(mem_ctx, temp, else_discard);
-
-   ir_discard *discard = then_discard != NULL ? then_discard : else_discard;
-   discard->condition = new(mem_ctx) ir_dereference_variable(temp);
-   ir->insert_after(discard);
-
-   this->progress = true;
-
-   return visit_continue;
-}
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index 07ee91366ef..9cb51e323dd 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -197,7 +197,6 @@ files_libglsl = files(
   'link_uniform_blocks.cpp',
   'list.h',
   'lower_builtins.cpp',
-  'lower_discard.cpp',
   'lower_discard_flow.cpp',
   'lower_distance.cpp',
   'lower_instructions.cpp',
diff --git a/src/compiler/glsl/test_optpass.cpp b/src/compiler/glsl/test_optpass.cpp
index e0a2e8a0565..d875444587e 100644
--- a/src/compiler/glsl/test_optpass.cpp
+++ b/src/compiler/glsl/test_optpass.cpp
@@ -89,8 +89,6 @@ do_optimization(struct exec_list *ir, const char *optimization,
       return do_tree_grafting(ir);
    } else if (strcmp(optimization, "do_vec_index_to_cond_assign") == 0) {
       return do_vec_index_to_cond_assign(ir);
-   } else if (strcmp(optimization, "lower_discard") == 0) {
-      return lower_discard(ir);
    } else if (sscanf(optimization, "lower_instructions ( %d ) ",
                      &int_0) == 1) {
       return lower_instructions(ir, false, false);
diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index a83a0f74793..7c457fd98c4 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -510,8 +510,6 @@ st_link_glsl_to_nir(struct gl_context *ctx,
          struct gl_linked_shader *shader = shader_program->_LinkedShaders[i];
          exec_list *ir = shader->ir;
          gl_shader_stage stage = shader->Stage;
-         const struct gl_shader_compiler_options *options =
-               &ctx->Const.ShaderCompilerOptions[stage];
 
          enum pipe_shader_type ptarget = pipe_shader_type_from_mesa(stage);
          bool have_dround = pscreen->get_shader_param(pscreen, ptarget,
@@ -529,9 +527,6 @@ st_link_glsl_to_nir(struct gl_context *ctx,
                             ctx->Extensions.ARB_gpu_shader5);
 
          do_vec_index_to_cond_assign(ir);
-         if (options->MaxIfDepth == 0) {
-            lower_discard(ir);
-         }
 
          validate_ir_tree(ir);
       }
-- 
2.42.0

