From c42b1a5a7486338fec58931b21adcd4eb8a40f66 Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Wed, 18 Oct 2023 08:59:28 -0700
Subject: [PATCH 756/834] anv: prep for gen9 astc workaround

We will reuse astc emu for gen9 astc workaround.  This commit contains
minor cleanups and has no functional change.

Signed-off-by: Chia-I Wu <olvaffe@gmail.com>
Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/25800>
---
 src/intel/vulkan/anv_astc_emu.c | 58 +++++++++++++++++++--------------
 src/intel/vulkan/anv_blorp.c    | 20 ++++++------
 src/intel/vulkan/anv_image.c    |  5 +--
 src/intel/vulkan/anv_private.h  | 32 +++++++++++-------
 4 files changed, 68 insertions(+), 47 deletions(-)

diff --git a/src/intel/vulkan/anv_astc_emu.c b/src/intel/vulkan/anv_astc_emu.c
index d3014c7cde4..90fbd3b80f4 100644
--- a/src/intel/vulkan/anv_astc_emu.c
+++ b/src/intel/vulkan/anv_astc_emu.c
@@ -42,19 +42,18 @@ astc_emu_init_image_view(struct anv_cmd_buffer *cmd_buffer,
 static void
 astc_emu_init_push_descriptor_set(struct anv_cmd_buffer *cmd_buffer,
                                   struct anv_push_descriptor_set *push_set,
-                                  const struct vk_texcompress_astc_write_descriptor_set *writes)
+                                  VkDescriptorSetLayout _layout,
+                                  uint32_t write_count,
+                                  const VkWriteDescriptorSet *writes)
 {
    struct anv_device *device = cmd_buffer->device;
    struct anv_descriptor_set_layout *layout =
-      anv_descriptor_set_layout_from_handle(
-            device->texcompress_astc->ds_layout);
+      anv_descriptor_set_layout_from_handle(_layout);
 
    memset(push_set, 0, sizeof(*push_set));
    anv_push_descriptor_set_init(cmd_buffer, push_set, layout);
 
-   anv_descriptor_set_write(device, &push_set->set,
-                            ARRAY_SIZE(writes->descriptor_set),
-                            writes->descriptor_set);
+   anv_descriptor_set_write(device, &push_set->set, write_count, writes);
 }
 
 static void
@@ -66,11 +65,12 @@ astc_emu_decompress_slice(struct anv_cmd_buffer *cmd_buffer,
                           VkRect2D rect)
 {
    struct anv_device *device = cmd_buffer->device;
+   struct anv_device_astc_emu *astc_emu = &device->astc_emu;
    VkCommandBuffer cmd_buffer_ = anv_cmd_buffer_to_handle(cmd_buffer);
 
    VkPipeline pipeline =
       vk_texcompress_astc_get_decode_pipeline(&device->vk, &device->vk.alloc,
-                                              device->texcompress_astc,
+                                              astc_emu->texcompress,
                                               VK_NULL_HANDLE, astc_format);
    if (pipeline == VK_NULL_HANDLE) {
       anv_batch_set_error(&cmd_buffer->batch, VK_ERROR_UNKNOWN);
@@ -80,16 +80,19 @@ astc_emu_decompress_slice(struct anv_cmd_buffer *cmd_buffer,
    anv_CmdBindPipeline(cmd_buffer_, VK_PIPELINE_BIND_POINT_COMPUTE, pipeline);
 
    struct vk_texcompress_astc_write_descriptor_set writes;
-   vk_texcompress_astc_fill_write_descriptor_sets(device->texcompress_astc,
+   vk_texcompress_astc_fill_write_descriptor_sets(astc_emu->texcompress,
                                                   &writes, src_view, layout,
                                                   dst_view, astc_format);
 
    struct anv_push_descriptor_set push_set;
-   astc_emu_init_push_descriptor_set(cmd_buffer, &push_set, &writes);
+   astc_emu_init_push_descriptor_set(cmd_buffer, &push_set,
+                                     astc_emu->texcompress->ds_layout,
+                                     ARRAY_SIZE(writes.descriptor_set),
+                                     writes.descriptor_set);
 
    VkDescriptorSet set = anv_descriptor_set_to_handle(&push_set.set);
    anv_CmdBindDescriptorSets(cmd_buffer_, VK_PIPELINE_BIND_POINT_COMPUTE,
-                             device->texcompress_astc->p_layout, 0, 1, &set,
+                             astc_emu->texcompress->p_layout, 0, 1, &set,
                              0, NULL);
 
    const uint32_t push_const[] = {
@@ -101,7 +104,7 @@ astc_emu_decompress_slice(struct anv_cmd_buffer *cmd_buffer,
          vk_format_get_blockheight(astc_format),
       false, /* we don't use VK_IMAGE_VIEW_TYPE_3D */
    };
-   anv_CmdPushConstants(cmd_buffer_, device->texcompress_astc->p_layout,
+   anv_CmdPushConstants(cmd_buffer_, astc_emu->texcompress->p_layout,
                         VK_SHADER_STAGE_COMPUTE_BIT, 0,
                         sizeof(push_const), push_const);
 
@@ -118,12 +121,12 @@ astc_emu_decompress_slice(struct anv_cmd_buffer *cmd_buffer,
 }
 
 void
-anv_astc_emu_decompress(struct anv_cmd_buffer *cmd_buffer,
-                        struct anv_image *image,
-                        VkImageLayout layout,
-                        const VkImageSubresourceLayers *subresource,
-                        VkOffset3D block_offset,
-                        VkExtent3D block_extent)
+anv_astc_emu_process(struct anv_cmd_buffer *cmd_buffer,
+                     struct anv_image *image,
+                     VkImageLayout layout,
+                     const VkImageSubresourceLayers *subresource,
+                     VkOffset3D block_offset,
+                     VkExtent3D block_extent)
 {
    assert(image->emu_plane_format != VK_FORMAT_UNDEFINED);
 
@@ -138,7 +141,7 @@ anv_astc_emu_decompress(struct anv_cmd_buffer *cmd_buffer,
       },
    };
 
-   /* decompress one layer at a time because anv_image_fill_surface_state
+   /* process one layer at a time because anv_image_fill_surface_state
     * requires an uncompressed view of a compressed image to be single layer
     */
    const bool is_3d = image->vk.image_type == VK_IMAGE_TYPE_3D;
@@ -178,18 +181,25 @@ anv_astc_emu_decompress(struct anv_cmd_buffer *cmd_buffer,
 VkResult
 anv_device_init_astc_emu(struct anv_device *device)
 {
-   if (!device->physical->emu_astc_ldr)
-      return VK_SUCCESS;
+   struct anv_device_astc_emu *astc_emu = &device->astc_emu;
+   VkResult result = VK_SUCCESS;
 
-   return vk_texcompress_astc_init(&device->vk, &device->vk.alloc,
-                                   VK_NULL_HANDLE, &device->texcompress_astc);
+   if (device->physical->emu_astc_ldr) {
+      result = vk_texcompress_astc_init(&device->vk, &device->vk.alloc,
+                                        VK_NULL_HANDLE,
+                                        &astc_emu->texcompress);
+   }
+
+   return result;
 }
 
 void
 anv_device_finish_astc_emu(struct anv_device *device)
 {
-   if (device->texcompress_astc) {
+   struct anv_device_astc_emu *astc_emu = &device->astc_emu;
+
+   if (astc_emu->texcompress) {
       vk_texcompress_astc_finish(&device->vk, &device->vk.alloc,
-                                 device->texcompress_astc);
+                                 astc_emu->texcompress);
    }
 }
diff --git a/src/intel/vulkan/anv_blorp.c b/src/intel/vulkan/anv_blorp.c
index 1440c13c348..796eb8c484d 100644
--- a/src/intel/vulkan/anv_blorp.c
+++ b/src/intel/vulkan/anv_blorp.c
@@ -455,7 +455,7 @@ void anv_CmdCopyImage2(
          ANV_PIPE_HDC_PIPELINE_FLUSH_BIT :
          ANV_PIPE_RENDER_TARGET_CACHE_FLUSH_BIT;
       anv_add_pending_pipe_bits(cmd_buffer, pipe_bits,
-                                "Copy flush before decompression");
+                                "Copy flush before astc emu");
 
       for (unsigned r = 0; r < pCopyImageInfo->regionCount; r++) {
          const VkImageCopy2 *region = &pCopyImageInfo->pRegions[r];
@@ -463,10 +463,10 @@ void anv_CmdCopyImage2(
                &dst_image->vk, region->dstOffset);
          const VkExtent3D block_extent = vk_image_extent_to_elements(
                &src_image->vk, region->extent);
-         anv_astc_emu_decompress(cmd_buffer, dst_image,
-                                 pCopyImageInfo->dstImageLayout,
-                                 &region->dstSubresource,
-                                 block_offset, block_extent);
+         anv_astc_emu_process(cmd_buffer, dst_image,
+                              pCopyImageInfo->dstImageLayout,
+                              &region->dstSubresource,
+                              block_offset, block_extent);
       }
    }
 
@@ -630,7 +630,7 @@ void anv_CmdCopyBufferToImage2(
          ANV_PIPE_HDC_PIPELINE_FLUSH_BIT :
          ANV_PIPE_RENDER_TARGET_CACHE_FLUSH_BIT;
       anv_add_pending_pipe_bits(cmd_buffer, pipe_bits,
-                                "Copy flush before decompression");
+                                "Copy flush before astc emu");
 
       for (unsigned r = 0; r < pCopyBufferToImageInfo->regionCount; r++) {
          const VkBufferImageCopy2 *region =
@@ -639,10 +639,10 @@ void anv_CmdCopyBufferToImage2(
                &dst_image->vk, region->imageOffset);
          const VkExtent3D block_extent = vk_image_extent_to_elements(
                &dst_image->vk, region->imageExtent);
-         anv_astc_emu_decompress(cmd_buffer, dst_image,
-                                 pCopyBufferToImageInfo->dstImageLayout,
-                                 &region->imageSubresource,
-                                 block_offset, block_extent);
+         anv_astc_emu_process(cmd_buffer, dst_image,
+                              pCopyBufferToImageInfo->dstImageLayout,
+                              &region->imageSubresource,
+                              block_offset, block_extent);
       }
    }
 
diff --git a/src/intel/vulkan/anv_image.c b/src/intel/vulkan/anv_image.c
index 4f73ac52d62..24d27b571d3 100644
--- a/src/intel/vulkan/anv_image.c
+++ b/src/intel/vulkan/anv_image.c
@@ -1597,7 +1597,7 @@ anv_image_init(struct anv_device *device, struct anv_image *image,
       assert(!(image->vk.create_flags & VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT));
 
       image->emu_plane_format =
-         vk_texcompress_astc_emulation_format(image->vk.format);
+         anv_get_emulation_format(device->physical, image->vk.format);
 
       /* for fetching the raw copmressed data and storing the decompressed
        * data
@@ -3275,7 +3275,8 @@ anv_image_view_init(struct anv_device *device,
       VkFormat view_format = iview->vk.view_format;
       if (anv_is_format_emulated(device->physical, view_format)) {
          assert(image->emu_plane_format != VK_FORMAT_UNDEFINED);
-         view_format = vk_texcompress_astc_emulation_format(view_format);
+         view_format =
+            anv_get_emulation_format(device->physical, view_format);
       }
       const struct anv_format_plane format = anv_get_format_plane(
             device->info, view_format, vplane, image->vk.tiling);
diff --git a/src/intel/vulkan/anv_private.h b/src/intel/vulkan/anv_private.h
index 7a028ead514..83f9851cf1e 100644
--- a/src/intel/vulkan/anv_private.h
+++ b/src/intel/vulkan/anv_private.h
@@ -1460,6 +1460,10 @@ enum anv_rt_bvh_build_method {
    ANV_BVH_BUILD_METHOD_NEW_SAH,
 };
 
+struct anv_device_astc_emu {
+    struct vk_texcompress_astc_state           *texcompress;
+};
+
 struct anv_device {
     struct vk_device                            vk;
 
@@ -1641,7 +1645,7 @@ struct anv_device {
      */
     bool                                         using_sparse;
 
-    struct vk_texcompress_astc_state           *texcompress_astc;
+    struct anv_device_astc_emu                   astc_emu;
 };
 
 static inline uint32_t
@@ -4467,13 +4471,19 @@ bool anv_formats_ccs_e_compatible(const struct intel_device_info *devinfo,
 extern VkFormat
 vk_format_from_android(unsigned android_format, unsigned android_usage);
 
+static inline VkFormat
+anv_get_emulation_format(const struct anv_physical_device *pdevice, VkFormat format)
+{
+   if (pdevice->emu_astc_ldr)
+      return vk_texcompress_astc_emulation_format(format);
+
+   return VK_FORMAT_UNDEFINED;
+}
+
 static inline bool
 anv_is_format_emulated(const struct anv_physical_device *pdevice, VkFormat format)
 {
-   if (pdevice->emu_astc_ldr &&
-       vk_texcompress_astc_emulation_format(format) != VK_FORMAT_UNDEFINED)
-      return true;
-   return false;
+   return anv_get_emulation_format(pdevice, format) != VK_FORMAT_UNDEFINED;
 }
 
 static inline struct isl_swizzle
@@ -5384,12 +5394,12 @@ void anv_device_finish_internal_kernels(struct anv_device *device);
 
 VkResult anv_device_init_astc_emu(struct anv_device *device);
 void anv_device_finish_astc_emu(struct anv_device *device);
-void anv_astc_emu_decompress(struct anv_cmd_buffer *cmd_buffer,
-                             struct anv_image *image,
-                             VkImageLayout layout,
-                             const VkImageSubresourceLayers *subresource,
-                             VkOffset3D block_offset,
-                             VkExtent3D block_extent);
+void anv_astc_emu_process(struct anv_cmd_buffer *cmd_buffer,
+                          struct anv_image *image,
+                          VkImageLayout layout,
+                          const VkImageSubresourceLayers *subresource,
+                          VkOffset3D block_offset,
+                          VkExtent3D block_extent);
 
 /* This structure is used in 2 scenarios :
  *
-- 
2.42.0

