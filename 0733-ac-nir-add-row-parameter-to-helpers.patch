From 6ec72806b782c70bf3f43ebfdc9d3d19972da5af Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 1 Sep 2023 11:18:38 +0100
Subject: [PATCH 733/834] ac/nir: add row parameter to helpers
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Timur Krist√≥f <timur.kristof@gmail.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/25040>
---
 src/amd/common/ac_nir.c           | 57 +++++++++++++++++--------------
 src/amd/common/ac_nir.h           |  5 +--
 src/amd/common/ac_nir_lower_ngg.c | 16 ++++-----
 3 files changed, 43 insertions(+), 35 deletions(-)

diff --git a/src/amd/common/ac_nir.c b/src/amd/common/ac_nir.c
index 0e9709a1562..918105de865 100644
--- a/src/amd/common/ac_nir.c
+++ b/src/amd/common/ac_nir.c
@@ -179,15 +179,26 @@ ac_nir_store_var_components(nir_builder *b, nir_variable *var, nir_def *value,
    nir_store_var(b, var, value, writemask);
 }
 
+static nir_intrinsic_instr *
+export(nir_builder *b, nir_def *val, nir_def *row, unsigned base, unsigned flags,
+       unsigned write_mask)
+{
+   if (row) {
+      return nir_export_row_amd(b, val, row, .base = base, .flags = flags,
+                                .write_mask = write_mask);
+   } else {
+      return nir_export_amd(b, val, .base = base, .flags = flags,
+                            .write_mask = write_mask);
+   }
+}
+
 void
-ac_nir_export_primitive(nir_builder *b, nir_def *prim)
+ac_nir_export_primitive(nir_builder *b, nir_def *prim, nir_def *row)
 {
    unsigned write_mask = BITFIELD_MASK(prim->num_components);
 
-   nir_export_amd(b, nir_pad_vec4(b, prim),
-                  .base = V_008DFC_SQ_EXP_PRIM,
-                  .flags = AC_EXP_FLAG_DONE,
-                  .write_mask = write_mask);
+   export(b, nir_pad_vec4(b, prim), row, V_008DFC_SQ_EXP_PRIM, AC_EXP_FLAG_DONE,
+          write_mask);
 }
 
 static nir_def *
@@ -231,7 +242,8 @@ ac_nir_export_position(nir_builder *b,
                        bool force_vrs,
                        bool done,
                        uint64_t outputs_written,
-                       nir_def *(*outputs)[4])
+                       nir_def *(*outputs)[4],
+                       nir_def *row)
 {
    nir_intrinsic_instr *exp[4];
    unsigned exp_num = 0;
@@ -244,9 +256,7 @@ ac_nir_export_position(nir_builder *b,
       const unsigned pos_flags = gfx_level == GFX10 ? AC_EXP_FLAG_VALID_MASK : 0;
       nir_def *pos = get_pos0_output(b, outputs[VARYING_SLOT_POS]);
 
-      exp[exp_num] = nir_export_amd(
-         b, pos, .base = V_008DFC_SQ_EXP_POS + exp_num,
-         .flags = pos_flags, .write_mask = 0xf);
+      exp[exp_num] = export(b, pos, row, V_008DFC_SQ_EXP_POS + exp_num, pos_flags, 0xf);
       exp_num++;
    } else {
       exp_pos_offset++;
@@ -274,7 +284,6 @@ ac_nir_export_position(nir_builder *b,
    if ((outputs_written & mask) || force_vrs) {
       nir_def *zero = nir_imm_float(b, 0);
       nir_def *vec[4] = { zero, zero, zero, zero };
-      unsigned flags = 0;
       unsigned write_mask = 0;
 
       if (outputs_written & VARYING_BIT_PSIZ) {
@@ -320,21 +329,19 @@ ac_nir_export_position(nir_builder *b,
          }
       }
 
-      exp[exp_num] = nir_export_amd(
-         b, nir_vec(b, vec, 4),
-         .base = V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset,
-         .flags = flags,
-         .write_mask = write_mask);
+      exp[exp_num] = export(b, nir_vec(b, vec, 4), row,
+                            V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset,
+                            0, write_mask);
       exp_num++;
    }
 
    for (int i = 0; i < 2; i++) {
       if ((outputs_written & (VARYING_BIT_CLIP_DIST0 << i)) &&
           (clip_cull_mask & BITFIELD_RANGE(i * 4, 4))) {
-         exp[exp_num] = nir_export_amd(
-            b, get_export_output(b, outputs[VARYING_SLOT_CLIP_DIST0 + i]),
-            .base = V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset,
-            .write_mask = (clip_cull_mask >> (i * 4)) & 0xf);
+         exp[exp_num] = export(
+            b, get_export_output(b, outputs[VARYING_SLOT_CLIP_DIST0 + i]), row,
+            V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset, 0,
+            (clip_cull_mask >> (i * 4)) & 0xf);
          exp_num++;
       }
    }
@@ -351,10 +358,10 @@ ac_nir_export_position(nir_builder *b,
 
       for (int i = 0; i < 2; i++) {
          if (clip_cull_mask & BITFIELD_RANGE(i * 4, 4)) {
-            exp[exp_num] = nir_export_amd(
-               b, get_export_output(b, clip_dist + i * 4),
-               .base = V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset,
-               .write_mask = (clip_cull_mask >> (i * 4)) & 0xf);
+            exp[exp_num] = export(
+               b, get_export_output(b, clip_dist + i * 4), row,
+               V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset, 0,
+               (clip_cull_mask >> (i * 4)) & 0xf);
             exp_num++;
          }
       }
@@ -739,7 +746,7 @@ ac_nir_create_gs_copy_shader(const nir_shader *gs_nir,
             export_outputs &= ~VARYING_BIT_PSIZ;
 
          ac_nir_export_position(&b, gfx_level, clip_cull_mask, !has_param_exports,
-                                force_vrs, true, export_outputs, outputs.data);
+                                force_vrs, true, export_outputs, outputs.data, NULL);
 
          if (has_param_exports) {
             ac_nir_export_parameters(&b, param_offsets,
@@ -846,7 +853,7 @@ ac_nir_lower_legacy_vs(nir_shader *nir,
       export_outputs &= ~VARYING_BIT_PSIZ;
 
    ac_nir_export_position(&b, gfx_level, clip_cull_mask, !has_param_exports,
-                          force_vrs, true, export_outputs, outputs.data);
+                          force_vrs, true, export_outputs, outputs.data, NULL);
 
    if (has_param_exports) {
       ac_nir_export_parameters(&b, param_offsets,
diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 85720a2ba3f..dc0651a5fc3 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -75,7 +75,7 @@ ac_nir_store_var_components(nir_builder *b, nir_variable *var, nir_def *value,
                             unsigned component, unsigned writemask);
 
 void
-ac_nir_export_primitive(nir_builder *b, nir_def *prim);
+ac_nir_export_primitive(nir_builder *b, nir_def *prim, nir_def *row);
 
 void
 ac_nir_export_position(nir_builder *b,
@@ -85,7 +85,8 @@ ac_nir_export_position(nir_builder *b,
                        bool force_vrs,
                        bool done,
                        uint64_t outputs_written,
-                       nir_def *(*outputs)[4]);
+                       nir_def *(*outputs)[4],
+                       nir_def *row);
 
 void
 ac_nir_export_parameters(nir_builder *b,
diff --git a/src/amd/common/ac_nir_lower_ngg.c b/src/amd/common/ac_nir_lower_ngg.c
index ec051eaf1ac..874c51017f1 100644
--- a/src/amd/common/ac_nir_lower_ngg.c
+++ b/src/amd/common/ac_nir_lower_ngg.c
@@ -604,7 +604,7 @@ emit_ngg_nogs_prim_export(nir_builder *b, lower_ngg_nogs_state *s, nir_def *arg)
          arg = nir_iand(b, arg, mask);
       }
 
-      ac_nir_export_primitive(b, arg);
+      ac_nir_export_primitive(b, arg, NULL);
    }
    nir_pop_if(b, if_gs_thread);
 }
@@ -2367,7 +2367,7 @@ export_pos0_wait_attr_ring(nir_builder *b, nir_if *if_es_thread, nir_def *output
                              options->clipdist_enable_mask,
                              !options->has_param_exports,
                              options->force_vrs, true,
-                             VARYING_BIT_POS, pos_output_array);
+                             VARYING_BIT_POS, pos_output_array, NULL);
    }
    nir_pop_if(b, if_export_empty_pos);
 }
@@ -2619,7 +2619,7 @@ ac_nir_lower_ngg_nogs(nir_shader *shader, const ac_nir_lower_ngg_options *option
                           options->clipdist_enable_mask,
                           !options->has_param_exports,
                           options->force_vrs, !wait_attr_ring,
-                          export_outputs, state.outputs);
+                          export_outputs, state.outputs, NULL);
 
    nogs_export_vertex_params(b, impl, if_es_thread, num_es_threads, &state);
 
@@ -3043,7 +3043,7 @@ ngg_gs_export_primitives(nir_builder *b, nir_def *max_num_out_prims, nir_def *ti
 
    nir_def *arg = emit_pack_ngg_prim_exp_arg(b, s->num_vertices_per_primitive, vtx_indices,
                                                  is_null_prim);
-   ac_nir_export_primitive(b, arg);
+   ac_nir_export_primitive(b, arg, NULL);
    nir_pop_if(b, if_prim_export_thread);
 }
 
@@ -3128,7 +3128,7 @@ ngg_gs_export_vertices(nir_builder *b, nir_def *max_num_out_vtx, nir_def *tid_in
                           s->options->clipdist_enable_mask,
                           !s->options->has_param_exports,
                           s->options->force_vrs, !wait_attr_ring,
-                          export_outputs, s->outputs);
+                          export_outputs, s->outputs, NULL);
 
    nir_pop_if(b, if_vtx_export_thread);
 
@@ -4473,7 +4473,7 @@ ms_emit_primitive_export(nir_builder *b,
    nir_def *prim_exp_arg = prim_exp_arg_ch2 ?
       nir_vec2(b, prim_exp_arg_ch1, prim_exp_arg_ch2) : prim_exp_arg_ch1;
 
-   ac_nir_export_primitive(b, prim_exp_arg);
+   ac_nir_export_primitive(b, prim_exp_arg, NULL);
 }
 
 static void
@@ -4531,7 +4531,7 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
          if (!wait_attr_ring)
             ac_nir_export_position(b, s->gfx_level, s->clipdist_enable_mask,
                                  !s->has_param_exports, false, true,
-                                 s->per_vertex_outputs | VARYING_BIT_POS, s->outputs);
+                                 s->per_vertex_outputs | VARYING_BIT_POS, s->outputs, NULL);
 
          /* Export generic attributes on GFX10.3
          * (On GFX11 they are already stored in the attribute ring.)
@@ -4598,7 +4598,7 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
          ms_emit_arrayed_outputs(b, invocation_index, per_vertex_outputs, s);
          ac_nir_export_position(b, s->gfx_level, s->clipdist_enable_mask,
                                 !s->has_param_exports, false, true,
-                                s->per_vertex_outputs | VARYING_BIT_POS, s->outputs);
+                                s->per_vertex_outputs | VARYING_BIT_POS, s->outputs, NULL);
       }
       nir_pop_if(b, if_has_output_vertex);
 
-- 
2.42.0

