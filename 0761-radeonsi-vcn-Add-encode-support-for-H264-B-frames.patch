From 9b4fccf4b375bca6988fe821c5d8a1813b597f8f Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Wed, 4 Oct 2023 16:55:47 +0200
Subject: [PATCH 761/834] radeonsi/vcn: Add encode support for H264 B-frames

Tested with ffmpeg and gstreamer vah264enc.

References to B-frames (b_depth/b-pyramid) not supported.

Reviewed-by: Ruijing Dong <ruijing.dong@amd.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/25565>
---
 src/amd/common/ac_vcn_enc.h                   |   2 +
 src/gallium/drivers/radeonsi/radeon_vcn_enc.c |  16 +-
 .../drivers/radeonsi/radeon_vcn_enc_1_2.c     |  29 +-
 .../drivers/radeonsi/radeon_vcn_enc_3_0.c     | 299 +++++++++++++++++-
 .../drivers/radeonsi/radeon_vcn_enc_4_0.c     |   6 +-
 src/gallium/drivers/radeonsi/si_get.c         |   9 +
 6 files changed, 347 insertions(+), 14 deletions(-)

diff --git a/src/amd/common/ac_vcn_enc.h b/src/amd/common/ac_vcn_enc.h
index 41a63d7ddcd..dcb088ac8bd 100644
--- a/src/amd/common/ac_vcn_enc.h
+++ b/src/amd/common/ac_vcn_enc.h
@@ -373,6 +373,7 @@ typedef struct rvcn_enc_h264_encode_params_s {
    rvcn_enc_h264_reference_picture_info_t picture_info_l0_reference_picture1;
    uint32_t l1_reference_picture0_index;
    rvcn_enc_h264_reference_picture_info_t picture_info_l1_reference_picture0;
+   uint32_t is_reference;
 } rvcn_enc_h264_encode_params_t;
 
 typedef struct rvcn_enc_h264_deblocking_filter_s {
@@ -562,6 +563,7 @@ typedef struct rvcn_enc_vui_info_s
    uint32_t matrix_coefficients;
    uint32_t chroma_sample_loc_type_top_field;
    uint32_t chroma_sample_loc_type_bottom_field;
+   uint32_t max_num_reorder_frames;
 }rvcn_enc_vui_info;
 
 typedef struct rvcn_enc_input_format_s
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
index d79bcd101eb..49cedd12b28 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
@@ -106,6 +106,7 @@ static void radeon_vcn_enc_h264_get_spec_misc_param(struct radeon_encoder *enc,
       pic->pic_ctrl.deblocking_filter_control_present_flag;
    enc->enc_pic.spec_misc.redundant_pic_cnt_present_flag =
       pic->pic_ctrl.redundant_pic_cnt_present_flag;
+   enc->enc_pic.spec_misc.b_picture_enabled = !!pic->seq.max_num_reorder_frames;
 }
 
 static void radeon_vcn_enc_h264_get_rc_param(struct radeon_encoder *enc,
@@ -194,6 +195,7 @@ static void radeon_vcn_enc_h264_get_vui_param(struct radeon_encoder *enc,
       pic->seq.chroma_sample_loc_type_top_field;
    enc->enc_pic.vui_info.chroma_sample_loc_type_bottom_field =
       pic->seq.chroma_sample_loc_type_bottom_field;
+   enc->enc_pic.vui_info.max_num_reorder_frames = pic->seq.max_num_reorder_frames;
 }
 
 /* only checking the first slice to get num of mbs in slice to
@@ -780,9 +782,9 @@ static int setup_dpb(struct radeon_encoder *enc)
       full_size = align(full_size, 4);
 
       enc_pic->ctx_buf.two_pass_search_center_map_offset = offset;
-      if (is_h264)
+      if (is_h264 && !enc_pic->spec_misc.b_picture_enabled)
          offset += align((pre_size * 4 + full_size) * sizeof(uint32_t), enc->alignment);
-      else
+      else if (!is_h264)
          offset += align((pre_size * 52 + full_size) * sizeof(uint32_t), enc->alignment);
    } else
       enc_pic->ctx_buf.two_pass_search_center_map_offset = 0;
@@ -819,10 +821,16 @@ static int setup_dpb(struct radeon_encoder *enc)
    }
 
    enc_pic->ctx_buf.num_reconstructed_pictures = num_reconstructed_pictures;
-   enc_pic->ctx_buf.colloc_buffer_offset = 0;
-   enc->dpb_size = offset;
    enc->max_ltr_idx = 0;
 
+   if (enc_pic->spec_misc.b_picture_enabled) {
+      enc_pic->ctx_buf.colloc_buffer_offset = offset;
+      offset += (align((aligned_width / 16), 64) / 2) * (aligned_height / 16);
+   } else
+      enc_pic->ctx_buf.colloc_buffer_offset = 0;
+
+   enc->dpb_size = offset;
+
    return offset;
 }
 
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
index b74ecc9e812..aef49593e86 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
@@ -1476,6 +1476,27 @@ static void manage_dpb_before_encode(struct radeon_encoder *enc)
    assert(current_pic_idx >= 0);
 
    int ref0_idx = find_ref_idx(enc, enc->enc_pic.ref_idx_l0, enc->enc_pic.ref_idx_l0_is_ltr);
+   /* B-frames only supported on VCN >= 3.0 */
+   int ref1_idx = find_ref_idx(enc, enc->enc_pic.ref_idx_l1, enc->enc_pic.ref_idx_l1_is_ltr);
+
+   assert(enc->enc_pic.picture_type != PIPE_H2645_ENC_PICTURE_TYPE_P ||
+          ref0_idx != -1);
+   assert(enc->enc_pic.picture_type != PIPE_H2645_ENC_PICTURE_TYPE_B ||
+          (ref0_idx != -1 && ref1_idx != -1));
+
+   /* In case we didn't find the reference in dpb, we have to pick
+    * some valid index to prevent GPU hang. */
+   if ((enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P ||
+        enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) &&
+       ref0_idx == -1) {
+      RVID_ERR("Failed to find ref0 (%u).\n", enc->enc_pic.ref_idx_l0);
+      ref0_idx = (current_pic_idx + 1) % (enc->base.max_references + 1);
+   }
+
+   if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B && ref1_idx == -1) {
+      RVID_ERR("Failed to find ref1 (%u).\n", enc->enc_pic.ref_idx_l1);
+      ref1_idx = (current_pic_idx + 2) % (enc->base.max_references + 1);
+   }
 
    if (!enc->enc_pic.not_referenced)
       enc->dpb_info[current_pic_idx].in_use = true;
@@ -1488,11 +1509,15 @@ static void manage_dpb_before_encode(struct radeon_encoder *enc)
       enc->dpb_info[current_pic_idx].is_ltr = false;
    }
 
-   if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR)
+   if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR) {
       enc->enc_pic.enc_params.reference_picture_index = 0xFFFFFFFF;
-   else
+      enc->enc_pic.h264_enc_params.l1_reference_picture0_index = 0xFFFFFFFF;
+   } else {
       enc->enc_pic.enc_params.reference_picture_index = ref0_idx;
+      enc->enc_pic.h264_enc_params.l1_reference_picture0_index = ref1_idx;
+   }
    enc->enc_pic.enc_params.reconstructed_picture_index = current_pic_idx;
+   enc->enc_pic.h264_enc_params.is_reference = !enc->enc_pic.not_referenced;
 }
 
 void radeon_enc_1_2_init(struct radeon_encoder *enc)
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_3_0.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_3_0.c
index 294202e2d4a..1c193d0a264 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_3_0.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_3_0.c
@@ -17,7 +17,7 @@
 #include "radeon_vcn_enc.h"
 
 #define RENCODE_FW_INTERFACE_MAJOR_VERSION   1
-#define RENCODE_FW_INTERFACE_MINOR_VERSION   0
+#define RENCODE_FW_INTERFACE_MINOR_VERSION   20
 
 static void radeon_enc_spec_misc(struct radeon_encoder *enc)
 {
@@ -25,7 +25,6 @@ static void radeon_enc_spec_misc(struct radeon_encoder *enc)
    enc->enc_pic.spec_misc.half_pel_enabled = 1;
    enc->enc_pic.spec_misc.quarter_pel_enabled = 1;
    enc->enc_pic.spec_misc.level_idc = enc->base.level;
-   enc->enc_pic.spec_misc.b_picture_enabled = 0;
    enc->enc_pic.spec_misc.weighted_bipred_idc = 0;
 
    RADEON_ENC_BEGIN(enc->cmd.spec_misc_h264);
@@ -65,7 +64,6 @@ static void radeon_enc_encode_params_h264(struct radeon_encoder *enc)
    enc->enc_pic.h264_enc_params.input_pic_order_cnt = 0;
    enc->enc_pic.h264_enc_params.interlaced_mode = RENCODE_H264_INTERLACING_MODE_PROGRESSIVE;
    enc->enc_pic.h264_enc_params.l0_reference_picture1_index = 0xFFFFFFFF;
-   enc->enc_pic.h264_enc_params.l1_reference_picture0_index= 0xFFFFFFFF;
 
    RADEON_ENC_BEGIN(enc->cmd.enc_params_h264);
    RADEON_ENC_CS(enc->enc_pic.h264_enc_params.input_picture_structure);
@@ -85,6 +83,298 @@ static void radeon_enc_encode_params_h264(struct radeon_encoder *enc)
    RADEON_ENC_CS(enc->enc_pic.h264_enc_params.picture_info_l1_reference_picture0.is_long_term);
    RADEON_ENC_CS(enc->enc_pic.h264_enc_params.picture_info_l1_reference_picture0.picture_structure);
    RADEON_ENC_CS(enc->enc_pic.h264_enc_params.picture_info_l1_reference_picture0.pic_order_cnt);
+   RADEON_ENC_CS(enc->enc_pic.h264_enc_params.is_reference);
+   RADEON_ENC_END();
+}
+
+static void radeon_enc_quality_params(struct radeon_encoder *enc)
+{
+   enc->enc_pic.quality_params.vbaq_mode = enc->enc_pic.quality_modes.vbaq_mode;
+   enc->enc_pic.quality_params.scene_change_sensitivity = 0;
+   enc->enc_pic.quality_params.scene_change_min_idr_interval = 0;
+   enc->enc_pic.quality_params.two_pass_search_center_map_mode =
+      (enc->enc_pic.quality_modes.pre_encode_mode &&
+       !enc->enc_pic.spec_misc.b_picture_enabled) ? 1 : 0;
+   enc->enc_pic.quality_params.vbaq_strength = 0;
+
+   RADEON_ENC_BEGIN(enc->cmd.quality_params);
+   RADEON_ENC_CS(enc->enc_pic.quality_params.vbaq_mode);
+   RADEON_ENC_CS(enc->enc_pic.quality_params.scene_change_sensitivity);
+   RADEON_ENC_CS(enc->enc_pic.quality_params.scene_change_min_idr_interval);
+   RADEON_ENC_CS(enc->enc_pic.quality_params.two_pass_search_center_map_mode);
+   RADEON_ENC_CS(enc->enc_pic.quality_params.vbaq_strength);
+   RADEON_ENC_END();
+}
+
+static void radeon_enc_nalu_sps(struct radeon_encoder *enc)
+{
+   struct radeon_enc_pic *pic = &enc->enc_pic;
+   RADEON_ENC_BEGIN(enc->cmd.nalu);
+   RADEON_ENC_CS(RENCODE_DIRECT_OUTPUT_NALU_TYPE_SPS);
+   uint32_t *size_in_bytes = &enc->cs.current.buf[enc->cs.current.cdw++];
+   radeon_enc_reset(enc);
+   radeon_enc_set_emulation_prevention(enc, false);
+   radeon_enc_code_fixed_bits(enc, 0x00000001, 32);
+   radeon_enc_code_fixed_bits(enc, 0x67, 8);
+   radeon_enc_byte_align(enc);
+   radeon_enc_set_emulation_prevention(enc, true);
+   radeon_enc_code_fixed_bits(enc, pic->spec_misc.profile_idc, 8);
+   radeon_enc_code_fixed_bits(enc, 0x0, 8); /* constraint_set_flags */
+   radeon_enc_code_fixed_bits(enc, pic->spec_misc.level_idc, 8);
+   radeon_enc_code_ue(enc, 0x0);
+
+   if (pic->spec_misc.profile_idc == 100 || pic->spec_misc.profile_idc == 110 ||
+       pic->spec_misc.profile_idc == 122 || pic->spec_misc.profile_idc == 244 ||
+       pic->spec_misc.profile_idc == 44  || pic->spec_misc.profile_idc == 83 ||
+       pic->spec_misc.profile_idc == 86  || pic->spec_misc.profile_idc == 118 ||
+       pic->spec_misc.profile_idc == 128 || pic->spec_misc.profile_idc == 138) {
+      radeon_enc_code_ue(enc, 0x1);
+      radeon_enc_code_ue(enc, 0x0);
+      radeon_enc_code_ue(enc, 0x0);
+      radeon_enc_code_fixed_bits(enc, 0x0, 2);
+   }
+
+   radeon_enc_code_ue(enc, 1);
+   radeon_enc_code_ue(enc, pic->pic_order_cnt_type);
+
+   if (pic->pic_order_cnt_type == 0)
+      radeon_enc_code_ue(enc, 1);
+
+   radeon_enc_code_ue(enc, enc->base.max_references);
+   radeon_enc_code_fixed_bits(enc, pic->layer_ctrl.max_num_temporal_layers > 1 ? 0x1 : 0x0,
+                              1);
+   radeon_enc_code_ue(enc, (pic->session_init.aligned_picture_width / 16 - 1));
+   radeon_enc_code_ue(enc, (pic->session_init.aligned_picture_height / 16 - 1));
+   bool progressive_only = true;
+   radeon_enc_code_fixed_bits(enc, progressive_only ? 0x1 : 0x0, 1);
+
+   if (!progressive_only)
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);
+
+   radeon_enc_code_fixed_bits(enc, 0x1, 1);
+
+   if ((pic->crop_left != 0) || (pic->crop_right  != 0) ||
+       (pic->crop_top  != 0) || (pic->crop_bottom != 0)) {
+      radeon_enc_code_fixed_bits(enc, 0x1, 1);
+      radeon_enc_code_ue(enc, pic->crop_left);
+      radeon_enc_code_ue(enc, pic->crop_right);
+      radeon_enc_code_ue(enc, pic->crop_top);
+      radeon_enc_code_ue(enc, pic->crop_bottom);
+   } else
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);
+
+   /* VUI present flag */
+   radeon_enc_code_fixed_bits(enc, pic->vui_info.vui_parameters_present_flag, 1);
+   if (pic->vui_info.vui_parameters_present_flag) {
+      /* aspect ratio present flag */
+      radeon_enc_code_fixed_bits(enc, (pic->vui_info.flags.aspect_ratio_info_present_flag), 1);
+      if (pic->vui_info.flags.aspect_ratio_info_present_flag) {
+         radeon_enc_code_fixed_bits(enc, (pic->vui_info.aspect_ratio_idc), 8);
+         if (pic->vui_info.aspect_ratio_idc == PIPE_H2645_EXTENDED_SAR) {
+            radeon_enc_code_fixed_bits(enc, (pic->vui_info.sar_width), 16);
+            radeon_enc_code_fixed_bits(enc, (pic->vui_info.sar_height), 16);
+         }
+      }
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* overscan info present flag */
+      /* video signal type present flag  */
+      radeon_enc_code_fixed_bits(enc, pic->vui_info.flags.video_signal_type_present_flag, 1);
+      if (pic->vui_info.flags.video_signal_type_present_flag) {
+         radeon_enc_code_fixed_bits(enc, pic->vui_info.video_format, 3);
+         radeon_enc_code_fixed_bits(enc, pic->vui_info.video_full_range_flag, 1);
+         radeon_enc_code_fixed_bits(enc, pic->vui_info.flags.colour_description_present_flag, 1);
+         if (pic->vui_info.flags.colour_description_present_flag) {
+            radeon_enc_code_fixed_bits(enc, pic->vui_info.colour_primaries, 8);
+            radeon_enc_code_fixed_bits(enc, pic->vui_info.transfer_characteristics, 8);
+            radeon_enc_code_fixed_bits(enc, pic->vui_info.matrix_coefficients, 8);
+         }
+      }
+      /* chroma loc info present flag */
+      radeon_enc_code_fixed_bits(enc, pic->vui_info.flags.chroma_loc_info_present_flag, 1);
+      if (pic->vui_info.flags.chroma_loc_info_present_flag) {
+         radeon_enc_code_ue(enc, pic->vui_info.chroma_sample_loc_type_top_field);
+         radeon_enc_code_ue(enc, pic->vui_info.chroma_sample_loc_type_bottom_field);
+      }
+      /* timing info present flag */
+      radeon_enc_code_fixed_bits(enc, (pic->vui_info.flags.timing_info_present_flag), 1);
+      if (pic->vui_info.flags.timing_info_present_flag) {
+         radeon_enc_code_fixed_bits(enc, (pic->vui_info.num_units_in_tick), 32);
+         radeon_enc_code_fixed_bits(enc, (pic->vui_info.time_scale), 32);
+         radeon_enc_code_fixed_bits(enc, 0x0, 1);
+      }
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* nal hrd parameters present flag */
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* vcl hrd parameters present flag */
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* pic_struct_present flag */
+      radeon_enc_code_fixed_bits(enc, 0x1, 1);  /* bitstream_restriction_flag */
+      radeon_enc_code_fixed_bits(enc, 0x1, 1);  /* motion_vectors_over_pic_boundaries_flag */
+      radeon_enc_code_ue(enc, 0x0);
+      radeon_enc_code_ue(enc, 0x0);
+      radeon_enc_code_ue(enc, 16);
+      radeon_enc_code_ue(enc, 16);
+      radeon_enc_code_ue(enc, pic->vui_info.max_num_reorder_frames);
+      radeon_enc_code_ue(enc, enc->base.max_references); /* max_dec_frame_buffering */
+   }
+   radeon_enc_code_fixed_bits(enc, 0x1, 1);
+
+   radeon_enc_byte_align(enc);
+   radeon_enc_flush_headers(enc);
+   *size_in_bytes = (enc->bits_output + 7) / 8;
+   RADEON_ENC_END();
+}
+
+static void radeon_enc_slice_header(struct radeon_encoder *enc)
+{
+   uint32_t instruction[RENCODE_SLICE_HEADER_TEMPLATE_MAX_NUM_INSTRUCTIONS] = {0};
+   uint32_t num_bits[RENCODE_SLICE_HEADER_TEMPLATE_MAX_NUM_INSTRUCTIONS] = {0};
+   unsigned int inst_index = 0;
+   unsigned int cdw_start = 0;
+   unsigned int cdw_filled = 0;
+   unsigned int bits_copied = 0;
+   RADEON_ENC_BEGIN(enc->cmd.slice_header);
+   radeon_enc_reset(enc);
+   radeon_enc_set_emulation_prevention(enc, false);
+
+   cdw_start = enc->cs.current.cdw;
+   if (enc->enc_pic.is_idr)
+      radeon_enc_code_fixed_bits(enc, 0x65, 8);
+   else if (enc->enc_pic.not_referenced)
+      radeon_enc_code_fixed_bits(enc, 0x01, 8);
+   else
+      radeon_enc_code_fixed_bits(enc, 0x41, 8);
+
+   radeon_enc_flush_headers(enc);
+   instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
+   num_bits[inst_index] = enc->bits_output - bits_copied;
+   bits_copied = enc->bits_output;
+   inst_index++;
+
+   instruction[inst_index] = RENCODE_H264_HEADER_INSTRUCTION_FIRST_MB;
+   inst_index++;
+
+   switch (enc->enc_pic.picture_type) {
+   case PIPE_H2645_ENC_PICTURE_TYPE_I:
+   case PIPE_H2645_ENC_PICTURE_TYPE_IDR:
+      radeon_enc_code_fixed_bits(enc, 0x08, 7);
+      break;
+   case PIPE_H2645_ENC_PICTURE_TYPE_P:
+   case PIPE_H2645_ENC_PICTURE_TYPE_SKIP:
+      radeon_enc_code_fixed_bits(enc, 0x06, 5);
+      break;
+   case PIPE_H2645_ENC_PICTURE_TYPE_B:
+      radeon_enc_code_fixed_bits(enc, 0x07, 5);
+      break;
+   default:
+      radeon_enc_code_fixed_bits(enc, 0x08, 7);
+   }
+
+   radeon_enc_code_ue(enc, 0x0);
+   radeon_enc_code_fixed_bits(enc, enc->enc_pic.frame_num % 32, 5);
+
+   if (enc->enc_pic.h264_enc_params.input_picture_structure !=
+       RENCODE_H264_PICTURE_STRUCTURE_FRAME) {
+      radeon_enc_code_fixed_bits(enc, 0x1, 1);
+      radeon_enc_code_fixed_bits(enc,
+                                 enc->enc_pic.h264_enc_params.input_picture_structure ==
+                                       RENCODE_H264_PICTURE_STRUCTURE_BOTTOM_FIELD
+                                    ? 1
+                                    : 0,
+                                 1);
+   }
+
+   if (enc->enc_pic.is_idr)
+      radeon_enc_code_ue(enc, enc->enc_pic.is_even_frame);
+
+   enc->enc_pic.is_even_frame = !enc->enc_pic.is_even_frame;
+
+   if (enc->enc_pic.pic_order_cnt_type == 0)
+      radeon_enc_code_fixed_bits(enc, enc->enc_pic.pic_order_cnt % 32, 5);
+
+   if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B)
+      radeon_enc_code_fixed_bits(enc, 0x1, 1); /* direct_spatial_mv_pred_flag */
+
+   /* ref_pic_list_modification() */
+   if (enc->enc_pic.picture_type != PIPE_H2645_ENC_PICTURE_TYPE_IDR) {
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);
+
+      /* long-term reference */
+      if (enc->enc_pic.ref_idx_l0_is_ltr) {
+         radeon_enc_code_fixed_bits(enc, 0x1, 1);            /* ref_pic_list_modification_flag_l0 */
+         radeon_enc_code_ue(enc, 0x2);                       /* modification_of_pic_nums_idc */
+         radeon_enc_code_ue(enc, enc->enc_pic.ref_idx_l0);   /* long_term_pic_num */
+         radeon_enc_code_ue(enc, 0x3);
+      }
+
+      /* short-term reference */
+      else if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) {
+         radeon_enc_code_fixed_bits(enc, 0x0, 1); /* ref_pic_list_modification_flag_l0 */
+         radeon_enc_code_fixed_bits(enc, 0x0, 1); /* ref_pic_list_modification_flag_l1 */
+      }
+      /* list_mod_diff_pic_minus1 != 0 */
+      else if (enc->enc_pic.frame_num - enc->enc_pic.ref_idx_l0 > 1) {
+         radeon_enc_code_fixed_bits(enc, 0x1, 1);  /* ref_pic_list_modification_flag_l0 */
+         radeon_enc_code_ue(enc, 0x0);             /* modification_of_pic_nums_idc */
+         /* abs_diff_pic_num_minus1 */
+         radeon_enc_code_ue(enc, (enc->enc_pic.frame_num - enc->enc_pic.ref_idx_l0 - 1));
+         radeon_enc_code_ue(enc, 0x3);
+      } else
+         radeon_enc_code_fixed_bits(enc, 0x0, 1);
+   }
+
+   if (enc->enc_pic.is_idr) {
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);
+      if (enc->enc_pic.is_ltr)
+         radeon_enc_code_fixed_bits(enc, 0x1, 1); /* long_term_reference_flag */
+      else
+         radeon_enc_code_fixed_bits(enc, 0x0, 1);
+   } else if (!enc->enc_pic.not_referenced) {
+      if (enc->enc_pic.is_ltr) {
+         radeon_enc_code_fixed_bits(enc, 0x1, 1);
+         radeon_enc_code_ue(enc, 0x4); /* memory_management_control_operation */
+         radeon_enc_code_ue(enc, enc->max_ltr_idx + 1); /* max_long_term_frame_idx_plus1 */
+         radeon_enc_code_ue(enc, 0x6); /*memory_management_control_operation */
+         radeon_enc_code_ue(enc, enc->enc_pic.ltr_idx); /* long_term_frame_idx */
+         radeon_enc_code_ue(enc, 0x0); /*memory_management_control_operation end*/
+      } else
+         radeon_enc_code_fixed_bits(enc, 0x0, 1);
+   }
+
+   if ((enc->enc_pic.picture_type != PIPE_H2645_ENC_PICTURE_TYPE_IDR) &&
+       (enc->enc_pic.spec_misc.cabac_enable))
+      radeon_enc_code_ue(enc, enc->enc_pic.spec_misc.cabac_init_idc);
+
+   radeon_enc_flush_headers(enc);
+   instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
+   num_bits[inst_index] = enc->bits_output - bits_copied;
+   bits_copied = enc->bits_output;
+   inst_index++;
+
+   instruction[inst_index] = RENCODE_H264_HEADER_INSTRUCTION_SLICE_QP_DELTA;
+   inst_index++;
+
+   if (enc->enc_pic.spec_misc.deblocking_filter_control_present_flag) {
+      radeon_enc_code_ue(enc, enc->enc_pic.h264_deblock.disable_deblocking_filter_idc);
+      if (!enc->enc_pic.h264_deblock.disable_deblocking_filter_idc) {
+         radeon_enc_code_se(enc, enc->enc_pic.h264_deblock.alpha_c0_offset_div2);
+         radeon_enc_code_se(enc, enc->enc_pic.h264_deblock.beta_offset_div2);
+      }
+   }
+
+   radeon_enc_flush_headers(enc);
+   instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
+   num_bits[inst_index] = enc->bits_output - bits_copied;
+   bits_copied = enc->bits_output;
+   inst_index++;
+
+   instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_END;
+
+   cdw_filled = enc->cs.current.cdw - cdw_start;
+   for (int i = 0; i < RENCODE_SLICE_HEADER_TEMPLATE_MAX_TEMPLATE_SIZE_IN_DWORDS - cdw_filled; i++)
+      RADEON_ENC_CS(0x00000000);
+
+   for (int j = 0; j < RENCODE_SLICE_HEADER_TEMPLATE_MAX_NUM_INSTRUCTIONS; j++) {
+      RADEON_ENC_CS(instruction[j]);
+      RADEON_ENC_CS(num_bits[j]);
+   }
+
    RADEON_ENC_END();
 }
 
@@ -233,10 +523,13 @@ void radeon_enc_3_0_init(struct radeon_encoder *enc)
 
    enc->session_init = radeon_enc_session_init;
    enc->ctx = radeon_enc_ctx;
+   enc->quality_params = radeon_enc_quality_params;
 
    if (u_reduce_video_profile(enc->base.profile) == PIPE_VIDEO_FORMAT_MPEG4_AVC) {
       enc->spec_misc = radeon_enc_spec_misc;
       enc->encode_params_codec_spec = radeon_enc_encode_params_h264;
+      enc->nalu_sps = radeon_enc_nalu_sps;
+      enc->slice_header = radeon_enc_slice_header;
    }
 
    if (u_reduce_video_profile(enc->base.profile) == PIPE_VIDEO_FORMAT_HEVC) {
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c
index 37fb9991e61..b7475345217 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c
@@ -16,7 +16,7 @@
 #include "radeon_vcn_enc.h"
 
 #define RENCODE_FW_INTERFACE_MAJOR_VERSION   1
-#define RENCODE_FW_INTERFACE_MINOR_VERSION   0
+#define RENCODE_FW_INTERFACE_MINOR_VERSION   11
 
 #define RENCODE_IB_PARAM_CDF_DEFAULT_TABLE_BUFFER  0x00000019
 #define RENCODE_IB_PARAM_ENCODE_STATISTICS         0x0000001a
@@ -957,10 +957,6 @@ static void radeon_enc_ctx(struct radeon_encoder *enc)
                                            == PIPE_VIDEO_FORMAT_AV1;
    enc->enc_pic.ctx_buf.swizzle_mode = radeon_enc_ref_swizzle_mode(enc);
    enc->enc_pic.ctx_buf.two_pass_search_center_map_offset = 0;
-   if (is_av1)
-      enc->enc_pic.ctx_buf.colloc_buffer_offset = 0;
-   else
-      enc->enc_pic.ctx_buf.colloc_buffer_offset = enc->dpb_size;
 
    RADEON_ENC_BEGIN(enc->cmd.ctx);
    RADEON_ENC_READWRITE(enc->dpb->res->buf, enc->dpb->res->domains, 0);
diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 1a74d1f9356..ffa895f2d61 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -751,6 +751,15 @@ static int si_get_video_param(struct pipe_screen *screen, enum pipe_video_profil
       case PIPE_VIDEO_CAP_EFC_SUPPORTED:
          return ((sscreen->info.family >= CHIP_RENOIR) &&
                  !(sscreen->debug_flags & DBG(NO_EFC)));
+
+      case PIPE_VIDEO_CAP_ENC_MAX_REFERENCES_PER_FRAME:
+         if (sscreen->info.vcn_ip_version >= VCN_3_0_0) {
+            int refPicList0 = 1;
+            int refPicList1 = codec == PIPE_VIDEO_FORMAT_MPEG4_AVC ? 1 : 0;
+            return refPicList0 | (refPicList1 << 16);
+         } else
+            return 1;
+
       default:
          return 0;
       }
-- 
2.42.0

