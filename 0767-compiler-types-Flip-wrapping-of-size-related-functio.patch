From 421a04f5ba7fbeea1b623a391f77e6a2e49dd3d7 Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Sat, 2 Sep 2023 11:25:49 -0700
Subject: [PATCH 767/834] compiler/types: Flip wrapping of size related
 functions

Reviewed-by: Kenneth Graunke <kenneth@whitecape.org>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/25129>
---
 src/compiler/glsl_types.cpp    | 113 ++++++++++++++++++---------------
 src/compiler/glsl_types.h      |  28 ++++++--
 src/compiler/glsl_types_impl.h |  36 +++--------
 src/compiler/nir_types.cpp     |  62 ------------------
 4 files changed, 96 insertions(+), 143 deletions(-)

diff --git a/src/compiler/glsl_types.cpp b/src/compiler/glsl_types.cpp
index 83e0ef378b7..7e349259786 100644
--- a/src/compiler/glsl_types.cpp
+++ b/src/compiler/glsl_types.cpp
@@ -1725,10 +1725,10 @@ glsl_type::field_index(const char *name) const
 }
 
 
-unsigned
-glsl_type::component_slots() const
+extern "C" unsigned
+glsl_get_component_slots(const struct glsl_type *t)
 {
-   switch (this->base_type) {
+   switch (t->base_type) {
    case GLSL_TYPE_UINT:
    case GLSL_TYPE_INT:
    case GLSL_TYPE_UINT8:
@@ -1738,25 +1738,25 @@ glsl_type::component_slots() const
    case GLSL_TYPE_FLOAT:
    case GLSL_TYPE_FLOAT16:
    case GLSL_TYPE_BOOL:
-      return this->components();
+      return t->components();
 
    case GLSL_TYPE_DOUBLE:
    case GLSL_TYPE_UINT64:
    case GLSL_TYPE_INT64:
-      return 2 * this->components();
+      return 2 * t->components();
 
    case GLSL_TYPE_STRUCT:
    case GLSL_TYPE_INTERFACE: {
       unsigned size = 0;
 
-      for (unsigned i = 0; i < this->length; i++)
-         size += this->fields.structure[i].type->component_slots();
+      for (unsigned i = 0; i < t->length; i++)
+         size += t->fields.structure[i].type->component_slots();
 
       return size;
    }
 
    case GLSL_TYPE_ARRAY:
-      return this->length * this->fields.array->component_slots();
+      return t->length * t->fields.array->component_slots();
 
    case GLSL_TYPE_SAMPLER:
    case GLSL_TYPE_TEXTURE:
@@ -1776,11 +1776,11 @@ glsl_type::component_slots() const
    return 0;
 }
 
-unsigned
-glsl_type::component_slots_aligned(unsigned offset) const
+extern "C" unsigned
+glsl_get_component_slots_aligned(const struct glsl_type *t, unsigned offset)
 {
    /* Align 64bit type only if it crosses attribute slot boundary. */
-   switch (this->base_type) {
+   switch (t->base_type) {
    case GLSL_TYPE_UINT:
    case GLSL_TYPE_INT:
    case GLSL_TYPE_UINT8:
@@ -1790,12 +1790,12 @@ glsl_type::component_slots_aligned(unsigned offset) const
    case GLSL_TYPE_FLOAT:
    case GLSL_TYPE_FLOAT16:
    case GLSL_TYPE_BOOL:
-      return this->components();
+      return t->components();
 
    case GLSL_TYPE_DOUBLE:
    case GLSL_TYPE_UINT64:
    case GLSL_TYPE_INT64: {
-      unsigned size = 2 * this->components();
+      unsigned size = 2 * t->components();
       if (offset % 2 == 1 && (offset % 4 + size) > 4) {
          size++;
       }
@@ -1807,8 +1807,8 @@ glsl_type::component_slots_aligned(unsigned offset) const
    case GLSL_TYPE_INTERFACE: {
       unsigned size = 0;
 
-      for (unsigned i = 0; i < this->length; i++) {
-         const struct glsl_type *member = this->fields.structure[i].type;
+      for (unsigned i = 0; i < t->length; i++) {
+         const struct glsl_type *member = t->fields.structure[i].type;
          size += member->component_slots_aligned(size + offset);
       }
 
@@ -1818,8 +1818,8 @@ glsl_type::component_slots_aligned(unsigned offset) const
    case GLSL_TYPE_ARRAY: {
       unsigned size = 0;
 
-      for (unsigned i = 0; i < this->length; i++) {
-         size += this->fields.array->component_slots_aligned(size + offset);
+      for (unsigned i = 0; i < t->length; i++) {
+         size += t->fields.array->component_slots_aligned(size + offset);
       }
 
       return size;
@@ -1920,12 +1920,12 @@ glsl_type::uniform_locations() const
    }
 }
 
-unsigned
-glsl_type::varying_count() const
+extern "C" unsigned
+glsl_varying_count(const struct glsl_type *t)
 {
    unsigned size = 0;
 
-   switch (this->base_type) {
+   switch (t->base_type) {
    case GLSL_TYPE_UINT:
    case GLSL_TYPE_INT:
    case GLSL_TYPE_FLOAT:
@@ -1942,17 +1942,17 @@ glsl_type::varying_count() const
 
    case GLSL_TYPE_STRUCT:
    case GLSL_TYPE_INTERFACE:
-      for (unsigned i = 0; i < this->length; i++)
-         size += this->fields.structure[i].type->varying_count();
+      for (unsigned i = 0; i < t->length; i++)
+         size += t->fields.structure[i].type->varying_count();
       return size;
    case GLSL_TYPE_ARRAY:
       /* Don't count innermost array elements */
-      if (this->without_array()->is_struct() ||
-          this->without_array()->is_interface() ||
-          this->fields.array->is_array())
-         return this->length * this->fields.array->varying_count();
+      if (t->without_array()->is_struct() ||
+          t->without_array()->is_interface() ||
+          t->fields.array->is_array())
+         return t->length * t->fields.array->varying_count();
       else
-         return this->fields.array->varying_count();
+         return t->fields.array->varying_count();
    default:
       assert(!"unsupported varying type");
       return 0;
@@ -2842,8 +2842,8 @@ glsl_type::replace_vec3_with_vec4() const
    }
 }
 
-unsigned
-glsl_type::count_vec4_slots(bool is_gl_vertex_input, bool is_bindless) const
+extern "C" unsigned
+glsl_count_vec4_slots(const struct glsl_type *t, bool is_gl_vertex_input, bool is_bindless)
 {
    /* From page 31 (page 37 of the PDF) of the GLSL 1.50 spec:
     *
@@ -2870,7 +2870,7 @@ glsl_type::count_vec4_slots(bool is_gl_vertex_input, bool is_bindless) const
     * take one location no matter what size they are, otherwise dvec3/4
     * take two locations.
     */
-   switch (this->base_type) {
+   switch (t->base_type) {
    case GLSL_TYPE_UINT:
    case GLSL_TYPE_INT:
    case GLSL_TYPE_UINT8:
@@ -2880,20 +2880,20 @@ glsl_type::count_vec4_slots(bool is_gl_vertex_input, bool is_bindless) const
    case GLSL_TYPE_FLOAT:
    case GLSL_TYPE_FLOAT16:
    case GLSL_TYPE_BOOL:
-      return this->matrix_columns;
+      return t->matrix_columns;
    case GLSL_TYPE_DOUBLE:
    case GLSL_TYPE_UINT64:
    case GLSL_TYPE_INT64:
-      if (this->vector_elements > 2 && !is_gl_vertex_input)
-         return this->matrix_columns * 2;
+      if (t->vector_elements > 2 && !is_gl_vertex_input)
+         return t->matrix_columns * 2;
       else
-         return this->matrix_columns;
+         return t->matrix_columns;
    case GLSL_TYPE_STRUCT:
    case GLSL_TYPE_INTERFACE: {
       unsigned size = 0;
 
-      for (unsigned i = 0; i < this->length; i++) {
-         const struct glsl_type *member_type = this->fields.structure[i].type;
+      for (unsigned i = 0; i < t->length; i++) {
+         const struct glsl_type *member_type = t->fields.structure[i].type;
          size += member_type->count_vec4_slots(is_gl_vertex_input, is_bindless);
       }
 
@@ -2901,9 +2901,9 @@ glsl_type::count_vec4_slots(bool is_gl_vertex_input, bool is_bindless) const
    }
 
    case GLSL_TYPE_ARRAY: {
-      const struct glsl_type *element = this->fields.array;
-      return this->length * element->count_vec4_slots(is_gl_vertex_input,
-                                                      is_bindless);
+      const struct glsl_type *element = t->fields.array;
+      return t->length * element->count_vec4_slots(is_gl_vertex_input,
+                                                   is_bindless);
    }
 
    case GLSL_TYPE_SAMPLER:
@@ -2929,22 +2929,22 @@ glsl_type::count_vec4_slots(bool is_gl_vertex_input, bool is_bindless) const
    return 0;
 }
 
-unsigned
-glsl_type::count_dword_slots(bool is_bindless) const
+extern "C" unsigned
+glsl_count_dword_slots(const struct glsl_type *t, bool is_bindless)
 {
-   switch (this->base_type) {
+   switch (t->base_type) {
    case GLSL_TYPE_UINT:
    case GLSL_TYPE_INT:
    case GLSL_TYPE_FLOAT:
    case GLSL_TYPE_BOOL:
-      return this->components();
+      return t->components();
    case GLSL_TYPE_UINT16:
    case GLSL_TYPE_INT16:
    case GLSL_TYPE_FLOAT16:
-      return DIV_ROUND_UP(this->vector_elements, 2) * this->matrix_columns;
+      return DIV_ROUND_UP(t->vector_elements, 2) * t->matrix_columns;
    case GLSL_TYPE_UINT8:
    case GLSL_TYPE_INT8:
-      return DIV_ROUND_UP(this->components(), 4);
+      return DIV_ROUND_UP(t->components(), 4);
    case GLSL_TYPE_IMAGE:
    case GLSL_TYPE_SAMPLER:
    case GLSL_TYPE_TEXTURE:
@@ -2954,16 +2954,16 @@ glsl_type::count_dword_slots(bool is_bindless) const
    case GLSL_TYPE_DOUBLE:
    case GLSL_TYPE_UINT64:
    case GLSL_TYPE_INT64:
-      return this->components() * 2;
+      return t->components() * 2;
    case GLSL_TYPE_ARRAY:
-      return this->fields.array->count_dword_slots(is_bindless) *
-             this->length;
+      return t->fields.array->count_dword_slots(is_bindless) *
+             t->length;
 
    case GLSL_TYPE_INTERFACE:
    case GLSL_TYPE_STRUCT: {
       unsigned size = 0;
-      for (unsigned i = 0; i < this->length; i++) {
-         size += this->fields.structure[i].type->count_dword_slots(is_bindless);
+      for (unsigned i = 0; i < t->length; i++) {
+         size += t->fields.structure[i].type->count_dword_slots(is_bindless);
       }
       return size;
    }
@@ -3500,7 +3500,20 @@ glsl_get_length(const struct glsl_type *t)
    return t->is_matrix() ? t->matrix_columns : t->length;
 }
 
+unsigned
+glsl_get_aoa_size(const struct glsl_type *t)
+{
+   if (!t->is_array())
+      return 0;
 
+   unsigned size = t->length;
+   const struct glsl_type *array_base_type = t->fields.array;
 
+   while (array_base_type->is_array()) {
+      size = size * array_base_type->length;
+      array_base_type = array_base_type->fields.array;
+   }
+   return size;
+}
 
 }
diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 1c9bd458ebe..f7e5e2ed678 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -1279,9 +1279,24 @@ glsl_struct_type_is_packed(const struct glsl_type *t)
 const struct glsl_type *glsl_get_bare_type(const struct glsl_type *t);
 
 unsigned glsl_get_length(const struct glsl_type *t);
-unsigned glsl_get_vector_elements(const struct glsl_type *t);
-unsigned glsl_get_components(const struct glsl_type *t);
-unsigned glsl_get_matrix_columns(const struct glsl_type *t);
+
+static inline unsigned
+glsl_get_vector_elements(const struct glsl_type *t)
+{
+   return t->vector_elements;
+}
+
+static inline unsigned
+glsl_get_components(const struct glsl_type *t)
+{
+   return t->vector_elements * t->matrix_columns;
+}
+
+static inline unsigned
+glsl_get_matrix_columns(const struct glsl_type *t)
+{
+   return t->matrix_columns;
+}
 
 static inline int
 glsl_array_size(const struct glsl_type *t)
@@ -1451,7 +1466,12 @@ unsigned glsl_count_dword_slots(const struct glsl_type *t, bool is_bindless);
 unsigned glsl_get_component_slots(const struct glsl_type *t);
 unsigned glsl_get_component_slots_aligned(const struct glsl_type *t, unsigned offset);
 unsigned glsl_varying_count(const struct glsl_type *t);
-unsigned glsl_count_attribute_slots(const struct glsl_type *t, bool is_gl_vertex_input);
+
+static inline unsigned
+glsl_count_attribute_slots(const struct glsl_type *t, bool is_gl_vertex_input)
+{
+   return glsl_count_vec4_slots(t, is_gl_vertex_input, true);
+}
 
 unsigned glsl_get_cl_size(const struct glsl_type *t);
 unsigned glsl_get_cl_alignment(const struct glsl_type *t);
diff --git a/src/compiler/glsl_types_impl.h b/src/compiler/glsl_types_impl.h
index 3aa9fc8754a..4f0fa342251 100644
--- a/src/compiler/glsl_types_impl.h
+++ b/src/compiler/glsl_types_impl.h
@@ -45,26 +45,22 @@ inline bool glsl_type::contains_opaque() const { return glsl_contains_opaque(thi
 inline bool glsl_type::contains_double() const { return glsl_contains_double(this); }
 inline bool glsl_type::contains_integer() const { return glsl_contains_integer(this); }
 
-inline unsigned
-glsl_type::components() const
-{
-   return vector_elements * matrix_columns;
-}
-
 inline int glsl_type::array_size() const { return glsl_array_size(this); }
 inline const glsl_type *glsl_type::without_array() const { return glsl_without_array(this); }
 
+inline unsigned glsl_type::components() const { return glsl_get_components(this); }
+inline unsigned glsl_type::component_slots() const { return glsl_get_component_slots(this); }
+inline unsigned glsl_type::component_slots_aligned(unsigned int offset) const { return glsl_get_component_slots_aligned(this, offset); }
+inline unsigned glsl_type::count_vec4_slots(bool is_gl_vertex_input, bool bindless) const { return glsl_count_vec4_slots(this, is_gl_vertex_input, bindless); }
+inline unsigned glsl_type::count_dword_slots(bool bindless) const { return glsl_count_dword_slots(this, bindless); };
+inline unsigned glsl_type::count_attribute_slots(bool is_gl_vertex_input) const { return glsl_count_attribute_slots(this, is_gl_vertex_input); }
+inline unsigned glsl_type::varying_count() const { return glsl_varying_count(this); }
+
 inline unsigned glsl_type::cl_size() const { return glsl_get_cl_size(this); }
 inline unsigned glsl_type::cl_alignment() const { return glsl_get_cl_alignment(this); }
 
 inline const glsl_type *glsl_type::get_bare_type() const { return glsl_get_bare_type(this); }
 
-inline unsigned
-glsl_type::count_attribute_slots(bool is_gl_vertex_input) const
-{
-   return count_vec4_slots(is_gl_vertex_input, true);
-}
-
 inline const glsl_type *glsl_type::vec(unsigned components) { return glsl_vec_type(components); }
 inline const glsl_type *glsl_type::f16vec(unsigned components) { return glsl_f16vec_type(components); }
 inline const glsl_type *glsl_type::dvec(unsigned components) { return glsl_dvec_type(components); }
@@ -174,21 +170,7 @@ glsl_type::is_anonymous() const
    return !strncmp(glsl_get_type_name(this), "#anon", 5);
 }
 
-inline unsigned
-glsl_type::arrays_of_arrays_size() const
-{
-   if (!is_array())
-      return 0;
-
-   unsigned size = length;
-   const glsl_type *array_base_type = fields.array;
-
-   while (array_base_type->is_array()) {
-      size = size * array_base_type->length;
-      array_base_type = array_base_type->fields.array;
-   }
-   return size;
-}
+inline unsigned glsl_type::arrays_of_arrays_size() const { return glsl_get_aoa_size(this); }
 
 inline unsigned
 glsl_type::bit_size() const
diff --git a/src/compiler/nir_types.cpp b/src/compiler/nir_types.cpp
index 5f52e0c7734..f5ccb98097e 100644
--- a/src/compiler/nir_types.cpp
+++ b/src/compiler/nir_types.cpp
@@ -99,68 +99,6 @@ glsl_get_base_type(const struct glsl_type *type)
    return type->base_type;
 }
 
-unsigned
-glsl_get_vector_elements(const struct glsl_type *type)
-{
-   return type->vector_elements;
-}
-
-unsigned
-glsl_get_components(const struct glsl_type *type)
-{
-   return type->components();
-}
-
-unsigned
-glsl_get_matrix_columns(const struct glsl_type *type)
-{
-   return type->matrix_columns;
-}
-
-unsigned
-glsl_get_aoa_size(const struct glsl_type *type)
-{
-   return type->arrays_of_arrays_size();
-}
-
-unsigned
-glsl_count_vec4_slots(const struct glsl_type *type,
-                      bool is_gl_vertex_input, bool is_bindless)
-{
-   return type->count_vec4_slots(is_gl_vertex_input, is_bindless);
-}
-
-unsigned
-glsl_count_dword_slots(const struct glsl_type *type, bool is_bindless)
-{
-   return type->count_dword_slots(is_bindless);
-}
-
-unsigned
-glsl_count_attribute_slots(const struct glsl_type *type,
-                           bool is_gl_vertex_input)
-{
-   return type->count_attribute_slots(is_gl_vertex_input);
-}
-
-unsigned
-glsl_get_component_slots(const struct glsl_type *type)
-{
-   return type->component_slots();
-}
-
-unsigned
-glsl_get_component_slots_aligned(const struct glsl_type *type, unsigned offset)
-{
-   return type->component_slots_aligned(offset);
-}
-
-unsigned
-glsl_varying_count(const struct glsl_type *type)
-{
-   return type->varying_count();
-}
-
 const char *
 glsl_get_struct_elem_name(const struct glsl_type *type, unsigned index)
 {
-- 
2.42.0

