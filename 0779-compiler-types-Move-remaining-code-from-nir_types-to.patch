From 68f80e6fc13ff1fff3d4ab2fd9cb67eefe4197ae Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Thu, 7 Sep 2023 17:47:32 -0700
Subject: [PATCH 779/834] compiler/types: Move remaining code from nir_types to
 glsl_types

Reviewed-by: Kenneth Graunke <kenneth@whitecape.org>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/25129>
---
 src/compiler/glsl_types.cpp | 215 +++++++++++++++++++++++++
 src/compiler/glsl_types.h   |  73 +++++++--
 src/compiler/meson.build    |   1 -
 src/compiler/nir_types.cpp  | 305 ------------------------------------
 4 files changed, 277 insertions(+), 317 deletions(-)
 delete mode 100644 src/compiler/nir_types.cpp

diff --git a/src/compiler/glsl_types.cpp b/src/compiler/glsl_types.cpp
index c7cc6575f19..6b576c6e2c3 100644
--- a/src/compiler/glsl_types.cpp
+++ b/src/compiler/glsl_types.cpp
@@ -3650,4 +3650,219 @@ glsl_type_to_16bit(const struct glsl_type *old_type)
    return old_type;
 }
 
+const struct glsl_type *
+glsl_replace_vector_type(const struct glsl_type *t, unsigned components)
+{
+   if (glsl_type_is_array(t)) {
+      return glsl_array_type(
+         glsl_replace_vector_type(t->fields.array, components), t->length,
+                                  t->explicit_stride);
+   } else if (glsl_type_is_vector_or_scalar(t)) {
+      return glsl_vector_type(t->base_type, components);
+   } else {
+      unreachable("Unhandled base type glsl_replace_vector_type()");
+   }
+}
+
+const struct glsl_type *
+glsl_channel_type(const struct glsl_type *t)
+{
+   switch (t->base_type) {
+   case GLSL_TYPE_ARRAY:
+      return glsl_array_type(glsl_channel_type(t->fields.array), t->length,
+                             t->explicit_stride);
+   case GLSL_TYPE_UINT:
+   case GLSL_TYPE_INT:
+   case GLSL_TYPE_FLOAT:
+   case GLSL_TYPE_FLOAT16:
+   case GLSL_TYPE_DOUBLE:
+   case GLSL_TYPE_UINT8:
+   case GLSL_TYPE_INT8:
+   case GLSL_TYPE_UINT16:
+   case GLSL_TYPE_INT16:
+   case GLSL_TYPE_UINT64:
+   case GLSL_TYPE_INT64:
+   case GLSL_TYPE_BOOL:
+      return glsl_type::get_instance(t->base_type, 1, 1);
+   default:
+      unreachable("Unhandled base type glsl_channel_type()");
+   }
+}
+
+static void
+glsl_size_align_handle_array_and_structs(const struct glsl_type *type,
+                                         glsl_type_size_align_func size_align,
+                                         unsigned *size, unsigned *align)
+{
+   if (type->base_type == GLSL_TYPE_ARRAY) {
+      unsigned elem_size = 0, elem_align = 0;
+      size_align(type->fields.array, &elem_size, &elem_align);
+      *align = elem_align;
+      *size = type->length * ALIGN_POT(elem_size, elem_align);
+   } else {
+      assert(type->base_type == GLSL_TYPE_STRUCT ||
+             type->base_type == GLSL_TYPE_INTERFACE);
+
+      *size = 0;
+      *align = 0;
+      for (unsigned i = 0; i < type->length; i++) {
+         unsigned elem_size = 0, elem_align = 0;
+         size_align(type->fields.structure[i].type, &elem_size, &elem_align);
+         *align = MAX2(*align, elem_align);
+         *size = ALIGN_POT(*size, elem_align) + elem_size;
+      }
+   }
+}
+
+void
+glsl_get_natural_size_align_bytes(const struct glsl_type *type,
+                                  unsigned *size, unsigned *align)
+{
+   switch (type->base_type) {
+   case GLSL_TYPE_BOOL:
+      /* We special-case Booleans to 32 bits to not cause heartburn for
+       * drivers that suddenly get an 8-bit load.
+       */
+      *size = 4 * type->components();
+      *align = 4;
+      break;
+
+   case GLSL_TYPE_UINT8:
+   case GLSL_TYPE_INT8:
+   case GLSL_TYPE_UINT16:
+   case GLSL_TYPE_INT16:
+   case GLSL_TYPE_FLOAT16:
+   case GLSL_TYPE_UINT:
+   case GLSL_TYPE_INT:
+   case GLSL_TYPE_FLOAT:
+   case GLSL_TYPE_DOUBLE:
+   case GLSL_TYPE_UINT64:
+   case GLSL_TYPE_INT64: {
+      unsigned N = glsl_get_bit_size(type) / 8;
+      *size = N * type->components();
+      *align = N;
+      break;
+   }
+
+   case GLSL_TYPE_ARRAY:
+   case GLSL_TYPE_INTERFACE:
+   case GLSL_TYPE_STRUCT:
+      glsl_size_align_handle_array_and_structs(type,
+                                               glsl_get_natural_size_align_bytes,
+                                               size, align);
+      break;
+
+   case GLSL_TYPE_SAMPLER:
+   case GLSL_TYPE_TEXTURE:
+   case GLSL_TYPE_IMAGE:
+      /* Bindless samplers and images. */
+      *size = 8;
+      *align = 8;
+      break;
+
+   case GLSL_TYPE_COOPERATIVE_MATRIX:
+   case GLSL_TYPE_ATOMIC_UINT:
+   case GLSL_TYPE_SUBROUTINE:
+   case GLSL_TYPE_VOID:
+   case GLSL_TYPE_ERROR:
+      unreachable("type does not have a natural size");
+   }
+}
+
+/**
+ * Returns a byte size/alignment for a type where each array element or struct
+ * field is aligned to 16 bytes.
+ */
+void
+glsl_get_vec4_size_align_bytes(const struct glsl_type *type,
+                               unsigned *size, unsigned *align)
+{
+   switch (type->base_type) {
+   case GLSL_TYPE_BOOL:
+      /* We special-case Booleans to 32 bits to not cause heartburn for
+       * drivers that suddenly get an 8-bit load.
+       */
+      *size = 4 * type->components();
+      *align = 16;
+      break;
+
+   case GLSL_TYPE_UINT8:
+   case GLSL_TYPE_INT8:
+   case GLSL_TYPE_UINT16:
+   case GLSL_TYPE_INT16:
+   case GLSL_TYPE_FLOAT16:
+   case GLSL_TYPE_UINT:
+   case GLSL_TYPE_INT:
+   case GLSL_TYPE_FLOAT:
+   case GLSL_TYPE_DOUBLE:
+   case GLSL_TYPE_UINT64:
+   case GLSL_TYPE_INT64: {
+      unsigned N = glsl_get_bit_size(type) / 8;
+      *size = 16 * (type->matrix_columns - 1) + N * type->vector_elements;
+      *align = 16;
+      break;
+   }
+
+   case GLSL_TYPE_ARRAY:
+   case GLSL_TYPE_INTERFACE:
+   case GLSL_TYPE_STRUCT:
+      glsl_size_align_handle_array_and_structs(type,
+                                               glsl_get_vec4_size_align_bytes,
+                                               size, align);
+      break;
+
+   case GLSL_TYPE_SAMPLER:
+   case GLSL_TYPE_TEXTURE:
+   case GLSL_TYPE_IMAGE:
+   case GLSL_TYPE_COOPERATIVE_MATRIX:
+   case GLSL_TYPE_ATOMIC_UINT:
+   case GLSL_TYPE_SUBROUTINE:
+   case GLSL_TYPE_VOID:
+   case GLSL_TYPE_ERROR:
+      unreachable("type does not make sense for glsl_get_vec4_size_align_bytes()");
+   }
+}
+
+static unsigned
+glsl_type_count(const struct glsl_type *type, enum glsl_base_type base_type)
+{
+   if (glsl_type_is_array(type)) {
+      return glsl_get_length(type) *
+             glsl_type_count(glsl_get_array_element(type), base_type);
+   }
+
+   /* Ignore interface blocks - they can only contain bindless samplers,
+    * which we shouldn't count.
+    */
+   if (glsl_type_is_struct(type)) {
+      unsigned count = 0;
+      for (unsigned i = 0; i < glsl_get_length(type); i++)
+         count += glsl_type_count(glsl_get_struct_field(type, i), base_type);
+      return count;
+   }
+
+   if (glsl_get_base_type(type) == base_type)
+      return 1;
+
+   return 0;
+}
+
+unsigned
+glsl_type_get_sampler_count(const struct glsl_type *type)
+{
+   return glsl_type_count(type, GLSL_TYPE_SAMPLER);
+}
+
+unsigned
+glsl_type_get_texture_count(const struct glsl_type *type)
+{
+   return glsl_type_count(type, GLSL_TYPE_TEXTURE);
+}
+
+unsigned
+glsl_type_get_image_count(const struct glsl_type *type)
+{
+   return glsl_type_count(type, GLSL_TYPE_IMAGE);
+}
+
 }
diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 839b13a6484..99c0ea5bf80 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -1485,17 +1485,68 @@ const struct glsl_type *glsl_int16_type(const struct glsl_type *t);
 const struct glsl_type *glsl_uint16_type(const struct glsl_type *t);
 const struct glsl_type *glsl_type_to_16bit(const struct glsl_type *old_type);
 
-const struct glsl_type *glsl_scalar_type(enum glsl_base_type base_type);
-const struct glsl_type *glsl_vector_type(enum glsl_base_type base_type, unsigned components);
-const struct glsl_type *glsl_matrix_type(enum glsl_base_type base_type,
-                                         unsigned rows, unsigned columns);
-const struct glsl_type *glsl_explicit_matrix_type(const struct glsl_type *mat,
-                                                  unsigned stride,
-                                                  bool row_major);
-
-const struct glsl_type *glsl_transposed_type(const struct glsl_type *t);
-const struct glsl_type *glsl_texture_type_to_sampler(const struct glsl_type *t, bool is_shadow);
-const struct glsl_type *glsl_sampler_type_to_texture(const struct glsl_type *t);
+static inline const struct glsl_type *
+glsl_scalar_type(enum glsl_base_type base_type)
+{
+   return glsl_simple_type(base_type, 1, 1, 0, false, 0);
+}
+
+static inline const struct glsl_type *
+glsl_vector_type(enum glsl_base_type base_type, unsigned components)
+{
+   const struct glsl_type *t = glsl_simple_type(base_type, components, 1, 0, false, 0);
+   assert(t != &glsl_type_builtin_error);
+   return t;
+}
+
+static inline const struct glsl_type *
+glsl_matrix_type(enum glsl_base_type base_type,
+                 unsigned rows, unsigned columns)
+{
+   const struct glsl_type *t = glsl_simple_type(base_type, rows, columns, 0, false, 0);
+   assert(t != &glsl_type_builtin_error);
+   return t;
+}
+
+static inline const struct glsl_type *
+glsl_explicit_matrix_type(const struct glsl_type *mat, unsigned stride,
+                          bool row_major) {
+   assert(stride > 0);
+   const struct glsl_type *t = glsl_simple_type(mat->base_type,
+                                                mat->vector_elements,
+                                                mat->matrix_columns,
+                                                stride, row_major, 0);
+   assert(t != &glsl_type_builtin_error);
+   return t;
+
+}
+
+static inline const struct glsl_type *
+glsl_transposed_type(const struct glsl_type *t)
+{
+   assert(glsl_type_is_matrix(t));
+   return glsl_simple_type(t->base_type, t->matrix_columns,
+                           t->vector_elements, 0, false, 0);
+}
+
+static inline const struct glsl_type *
+glsl_texture_type_to_sampler(const struct glsl_type *t, bool is_shadow)
+{
+   assert(glsl_type_is_texture(t));
+   return glsl_sampler_type((enum glsl_sampler_dim)t->sampler_dimensionality,
+                            is_shadow, t->sampler_array,
+                            (enum glsl_base_type)t->sampled_type);
+}
+
+static inline const struct glsl_type *
+glsl_sampler_type_to_texture(const struct glsl_type *t)
+{
+   assert(glsl_type_is_sampler(t) && !glsl_type_is_bare_sampler(t));
+   return glsl_texture_type((enum glsl_sampler_dim)t->sampler_dimensionality,
+                            t->sampler_array,
+                            (enum glsl_base_type)t->sampled_type);
+}
+
 const struct glsl_type *glsl_replace_vector_type(const struct glsl_type *t, unsigned components);
 const struct glsl_type *glsl_channel_type(const struct glsl_type *t);
 
diff --git a/src/compiler/meson.build b/src/compiler/meson.build
index 7d97e11ecc3..8438702ac7e 100644
--- a/src/compiler/meson.build
+++ b/src/compiler/meson.build
@@ -54,7 +54,6 @@ files_libcompiler = files(
   'glsl_types.cpp',
   'glsl_types.h',
   'glsl_types_impl.h',
-  'nir_types.cpp',
   'nir_types.h',
   'shader_enums.c',
   'shader_enums.h',
diff --git a/src/compiler/nir_types.cpp b/src/compiler/nir_types.cpp
deleted file mode 100644
index c84b7b843e2..00000000000
--- a/src/compiler/nir_types.cpp
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
- * Copyright © 2014 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- *
- * Authors:
- *    Connor Abbott (cwabbott0@gmail.com)
- *
- */
-
-#include "nir_types.h"
-#include "nir_gl_types.h"
-
-const struct glsl_type *
-glsl_texture_type_to_sampler(const struct glsl_type *type, bool is_shadow)
-{
-   assert(glsl_type_is_texture(type));
-   return glsl_sampler_type((glsl_sampler_dim)type->sampler_dimensionality,
-                            is_shadow, type->sampler_array,
-                            (enum glsl_base_type)type->sampled_type);
-}
-
-const struct glsl_type *
-glsl_sampler_type_to_texture(const struct glsl_type *type)
-{
-   assert(glsl_type_is_sampler(type) && !glsl_type_is_bare_sampler(type));
-   return glsl_texture_type((glsl_sampler_dim)type->sampler_dimensionality,
-                            type->sampler_array,
-                            (enum glsl_base_type)type->sampled_type);
-}
-
-const struct glsl_type *
-glsl_scalar_type(enum glsl_base_type base_type)
-{
-   return glsl_type::get_instance(base_type, 1, 1);
-}
-
-const struct glsl_type *
-glsl_vector_type(enum glsl_base_type base_type, unsigned components)
-{
-   const struct glsl_type *t = glsl_type::get_instance(base_type, components, 1);
-   assert(t != glsl_type::error_type);
-   return t;
-}
-
-const struct glsl_type *
-glsl_matrix_type(enum glsl_base_type base_type, unsigned rows, unsigned columns)
-{
-   const struct glsl_type *t = glsl_type::get_instance(base_type, rows, columns);
-   assert(t != glsl_type::error_type);
-   return t;
-}
-
-const struct glsl_type *
-glsl_explicit_matrix_type(const struct glsl_type *mat,
-                          unsigned stride, bool row_major)
-{
-   assert(stride > 0);
-   const struct glsl_type *t = glsl_type::get_instance(mat->base_type,
-                                                mat->vector_elements,
-                                                mat->matrix_columns,
-                                                stride, row_major);
-   assert(t != glsl_type::error_type);
-   return t;
-}
-
-const struct glsl_type *
-glsl_replace_vector_type(const struct glsl_type *t, unsigned components)
-{
-   if (glsl_type_is_array(t)) {
-      return glsl_array_type(
-         glsl_replace_vector_type(t->fields.array, components), t->length,
-                                  t->explicit_stride);
-   } else if (glsl_type_is_vector_or_scalar(t)) {
-      return glsl_vector_type(t->base_type, components);
-   } else {
-      unreachable("Unhandled base type glsl_replace_vector_type()");
-   }
-}
-
-const struct glsl_type *
-glsl_transposed_type(const struct glsl_type *type)
-{
-   assert(glsl_type_is_matrix(type));
-   return glsl_type::get_instance(type->base_type, type->matrix_columns,
-                                  type->vector_elements);
-}
-
-const struct glsl_type *
-glsl_channel_type(const struct glsl_type *t)
-{
-   switch (t->base_type) {
-   case GLSL_TYPE_ARRAY:
-      return glsl_array_type(glsl_channel_type(t->fields.array), t->length,
-                             t->explicit_stride);
-   case GLSL_TYPE_UINT:
-   case GLSL_TYPE_INT:
-   case GLSL_TYPE_FLOAT:
-   case GLSL_TYPE_FLOAT16:
-   case GLSL_TYPE_DOUBLE:
-   case GLSL_TYPE_UINT8:
-   case GLSL_TYPE_INT8:
-   case GLSL_TYPE_UINT16:
-   case GLSL_TYPE_INT16:
-   case GLSL_TYPE_UINT64:
-   case GLSL_TYPE_INT64:
-   case GLSL_TYPE_BOOL:
-      return glsl_type::get_instance(t->base_type, 1, 1);
-   default:
-      unreachable("Unhandled base type glsl_channel_type()");
-   }
-}
-
-static void
-glsl_size_align_handle_array_and_structs(const struct glsl_type *type,
-                                         glsl_type_size_align_func size_align,
-                                         unsigned *size, unsigned *align)
-{
-   if (type->base_type == GLSL_TYPE_ARRAY) {
-      unsigned elem_size = 0, elem_align = 0;
-      size_align(type->fields.array, &elem_size, &elem_align);
-      *align = elem_align;
-      *size = type->length * ALIGN_POT(elem_size, elem_align);
-   } else {
-      assert(type->base_type == GLSL_TYPE_STRUCT ||
-             type->base_type == GLSL_TYPE_INTERFACE);
-
-      *size = 0;
-      *align = 0;
-      for (unsigned i = 0; i < type->length; i++) {
-         unsigned elem_size = 0, elem_align = 0;
-         size_align(type->fields.structure[i].type, &elem_size, &elem_align);
-         *align = MAX2(*align, elem_align);
-         *size = ALIGN_POT(*size, elem_align) + elem_size;
-      }
-   }
-}
-
-void
-glsl_get_natural_size_align_bytes(const struct glsl_type *type,
-                                  unsigned *size, unsigned *align)
-{
-   switch (type->base_type) {
-   case GLSL_TYPE_BOOL:
-      /* We special-case Booleans to 32 bits to not cause heartburn for
-       * drivers that suddenly get an 8-bit load.
-       */
-      *size = 4 * type->components();
-      *align = 4;
-      break;
-
-   case GLSL_TYPE_UINT8:
-   case GLSL_TYPE_INT8:
-   case GLSL_TYPE_UINT16:
-   case GLSL_TYPE_INT16:
-   case GLSL_TYPE_FLOAT16:
-   case GLSL_TYPE_UINT:
-   case GLSL_TYPE_INT:
-   case GLSL_TYPE_FLOAT:
-   case GLSL_TYPE_DOUBLE:
-   case GLSL_TYPE_UINT64:
-   case GLSL_TYPE_INT64: {
-      unsigned N = glsl_get_bit_size(type) / 8;
-      *size = N * type->components();
-      *align = N;
-      break;
-   }
-
-   case GLSL_TYPE_ARRAY:
-   case GLSL_TYPE_INTERFACE:
-   case GLSL_TYPE_STRUCT:
-      glsl_size_align_handle_array_and_structs(type,
-                                               glsl_get_natural_size_align_bytes,
-                                               size, align);
-      break;
-
-   case GLSL_TYPE_SAMPLER:
-   case GLSL_TYPE_TEXTURE:
-   case GLSL_TYPE_IMAGE:
-      /* Bindless samplers and images. */
-      *size = 8;
-      *align = 8;
-      break;
-
-   case GLSL_TYPE_ATOMIC_UINT:
-   case GLSL_TYPE_SUBROUTINE:
-   case GLSL_TYPE_COOPERATIVE_MATRIX:
-   case GLSL_TYPE_VOID:
-   case GLSL_TYPE_ERROR:
-      unreachable("type does not have a natural size");
-   }
-}
-
-/**
- * Returns a byte size/alignment for a type where each array element or struct
- * field is aligned to 16 bytes.
- */
-void
-glsl_get_vec4_size_align_bytes(const struct glsl_type *type,
-                               unsigned *size, unsigned *align)
-{
-   switch (type->base_type) {
-   case GLSL_TYPE_BOOL:
-      /* We special-case Booleans to 32 bits to not cause heartburn for
-       * drivers that suddenly get an 8-bit load.
-       */
-      *size = 4 * type->components();
-      *align = 16;
-      break;
-
-   case GLSL_TYPE_UINT8:
-   case GLSL_TYPE_INT8:
-   case GLSL_TYPE_UINT16:
-   case GLSL_TYPE_INT16:
-   case GLSL_TYPE_FLOAT16:
-   case GLSL_TYPE_UINT:
-   case GLSL_TYPE_INT:
-   case GLSL_TYPE_FLOAT:
-   case GLSL_TYPE_DOUBLE:
-   case GLSL_TYPE_UINT64:
-   case GLSL_TYPE_INT64: {
-      unsigned N = glsl_get_bit_size(type) / 8;
-      *size = 16 * (type->matrix_columns - 1) + N * type->vector_elements;
-      *align = 16;
-      break;
-   }
-
-   case GLSL_TYPE_ARRAY:
-   case GLSL_TYPE_INTERFACE:
-   case GLSL_TYPE_STRUCT:
-      glsl_size_align_handle_array_and_structs(type,
-                                               glsl_get_vec4_size_align_bytes,
-                                               size, align);
-      break;
-
-   case GLSL_TYPE_SAMPLER:
-   case GLSL_TYPE_TEXTURE:
-   case GLSL_TYPE_IMAGE:
-   case GLSL_TYPE_ATOMIC_UINT:
-   case GLSL_TYPE_SUBROUTINE:
-   case GLSL_TYPE_COOPERATIVE_MATRIX:
-   case GLSL_TYPE_VOID:
-   case GLSL_TYPE_ERROR:
-      unreachable("type does not make sense for glsl_get_vec4_size_align_bytes()");
-   }
-}
-
-static unsigned
-glsl_type_count(const struct glsl_type *type, enum glsl_base_type base_type)
-{
-   if (glsl_type_is_array(type)) {
-      return glsl_get_length(type) *
-             glsl_type_count(glsl_get_array_element(type), base_type);
-   }
-
-   /* Ignore interface blocks - they can only contain bindless samplers,
-    * which we shouldn't count.
-    */
-   if (glsl_type_is_struct(type)) {
-      unsigned count = 0;
-      for (unsigned i = 0; i < glsl_get_length(type); i++)
-         count += glsl_type_count(glsl_get_struct_field(type, i), base_type);
-      return count;
-   }
-
-   if (glsl_get_base_type(type) == base_type)
-      return 1;
-
-   return 0;
-}
-
-unsigned
-glsl_type_get_sampler_count(const struct glsl_type *type)
-{
-   return glsl_type_count(type, GLSL_TYPE_SAMPLER);
-}
-
-unsigned
-glsl_type_get_texture_count(const struct glsl_type *type)
-{
-   return glsl_type_count(type, GLSL_TYPE_TEXTURE);
-}
-
-unsigned
-glsl_type_get_image_count(const struct glsl_type *type)
-{
-   return glsl_type_count(type, GLSL_TYPE_IMAGE);
-}
-- 
2.42.0

