From 64cf0d47b00183a8fecc8ccf9618d9483bdd106d Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Fri, 6 Oct 2023 15:53:35 +1000
Subject: [PATCH 082/834] lavapipe: handle planes in copies

This adds plane support to the various copy paths.

Reviewed-by: Roland Scheidegger <sroland@vmware.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/25609>
---
 src/gallium/frontends/lavapipe/lvp_execute.c | 29 ++++++++++-----
 src/gallium/frontends/lavapipe/lvp_image.c   | 38 +++++++++++++-------
 2 files changed, 45 insertions(+), 22 deletions(-)

diff --git a/src/gallium/frontends/lavapipe/lvp_execute.c b/src/gallium/frontends/lavapipe/lvp_execute.c
index 5b69d1499a4..abac8a6b47a 100644
--- a/src/gallium/frontends/lavapipe/lvp_execute.c
+++ b/src/gallium/frontends/lavapipe/lvp_execute.c
@@ -2179,6 +2179,9 @@ static void handle_copy_image_to_buffer2(struct vk_cmd_queue_entry *cmd,
 
    for (uint32_t i = 0; i < copycmd->regionCount; i++) {
       const VkBufferImageCopy2 *region = &copycmd->pRegions[i];
+      const VkImageAspectFlagBits aspects = copycmd->pRegions[i].imageSubresource.aspectMask;
+      uint8_t plane = lvp_image_aspects_to_plane(src_image, aspects);
+
       box.x = region->imageOffset.x;
       box.y = region->imageOffset.y;
       box.z = src_image->vk.image_type == VK_IMAGE_TYPE_3D ? region->imageOffset.z : region->imageSubresource.baseArrayLayer;
@@ -2187,7 +2190,7 @@ static void handle_copy_image_to_buffer2(struct vk_cmd_queue_entry *cmd,
       box.depth = src_image->vk.image_type == VK_IMAGE_TYPE_3D ? region->imageExtent.depth : subresource_layercount(src_image, &region->imageSubresource);
 
       src_data = state->pctx->texture_map(state->pctx,
-                                           src_image->planes[0].bo,
+                                           src_image->planes[plane].bo,
                                            region->imageSubresource.mipLevel,
                                            PIPE_MAP_READ,
                                            &box,
@@ -2206,7 +2209,7 @@ static void handle_copy_image_to_buffer2(struct vk_cmd_queue_entry *cmd,
                                            &dbox,
                                            &dst_t);
 
-      enum pipe_format src_format = src_image->planes[0].bo->format;
+      enum pipe_format src_format = src_image->planes[plane].bo->format;
       enum pipe_format dst_format = src_format;
       if (util_format_is_depth_or_stencil(src_format)) {
          if (region->imageSubresource.aspectMask == VK_IMAGE_ASPECT_DEPTH_BIT) {
@@ -2253,6 +2256,8 @@ static void handle_copy_buffer_to_image(struct vk_cmd_queue_entry *cmd,
       struct pipe_box box, sbox;
       struct pipe_transfer *src_t, *dst_t;
       void *src_data, *dst_data;
+      const VkImageAspectFlagBits aspects = copycmd->pRegions[i].imageSubresource.aspectMask;
+      uint8_t plane = lvp_image_aspects_to_plane(dst_image, aspects);
 
       sbox.x = region->bufferOffset;
       sbox.y = 0;
@@ -2276,17 +2281,17 @@ static void handle_copy_buffer_to_image(struct vk_cmd_queue_entry *cmd,
       box.depth = dst_image->vk.image_type == VK_IMAGE_TYPE_3D ? region->imageExtent.depth : subresource_layercount(dst_image, &region->imageSubresource);
 
       dst_data = state->pctx->texture_map(state->pctx,
-                                           dst_image->planes[0].bo,
+                                           dst_image->planes[plane].bo,
                                            region->imageSubresource.mipLevel,
                                            PIPE_MAP_WRITE,
                                            &box,
                                            &dst_t);
 
-      enum pipe_format dst_format = dst_image->planes[0].bo->format;
+      enum pipe_format dst_format = dst_image->planes[plane].bo->format;
       enum pipe_format src_format = dst_format;
       if (util_format_is_depth_or_stencil(dst_format)) {
          if (region->imageSubresource.aspectMask == VK_IMAGE_ASPECT_DEPTH_BIT) {
-            src_format = util_format_get_depth_only(dst_image->planes[0].bo->format);
+            src_format = util_format_get_depth_only(dst_image->planes[plane].bo->format);
          } else if (region->imageSubresource.aspectMask == VK_IMAGE_ASPECT_STENCIL_BIT) {
             src_format = PIPE_FORMAT_S8_UINT;
          }
@@ -2331,12 +2336,18 @@ static void handle_copy_image(struct vk_cmd_queue_entry *cmd,
 
    for (uint32_t i = 0; i < copycmd->regionCount; i++) {
       const VkImageCopy2 *region = &copycmd->pRegions[i];
+      const VkImageAspectFlagBits src_aspects =
+         copycmd->pRegions[i].srcSubresource.aspectMask;
+      uint8_t src_plane = lvp_image_aspects_to_plane(src_image, src_aspects);
+      const VkImageAspectFlagBits dst_aspects =
+         copycmd->pRegions[i].dstSubresource.aspectMask;
+      uint8_t dst_plane = lvp_image_aspects_to_plane(dst_image, dst_aspects);
       struct pipe_box src_box;
       src_box.x = region->srcOffset.x;
       src_box.y = region->srcOffset.y;
       src_box.width = region->extent.width;
       src_box.height = region->extent.height;
-      if (src_image->planes[0].bo->target == PIPE_TEXTURE_3D) {
+      if (src_image->planes[src_plane].bo->target == PIPE_TEXTURE_3D) {
          src_box.depth = region->extent.depth;
          src_box.z = region->srcOffset.z;
       } else {
@@ -2344,15 +2355,15 @@ static void handle_copy_image(struct vk_cmd_queue_entry *cmd,
          src_box.z = region->srcSubresource.baseArrayLayer;
       }
 
-      unsigned dstz = dst_image->planes[0].bo->target == PIPE_TEXTURE_3D ?
+      unsigned dstz = dst_image->planes[dst_plane].bo->target == PIPE_TEXTURE_3D ?
                       region->dstOffset.z :
                       region->dstSubresource.baseArrayLayer;
-      state->pctx->resource_copy_region(state->pctx, dst_image->planes[0].bo,
+      state->pctx->resource_copy_region(state->pctx, dst_image->planes[dst_plane].bo,
                                         region->dstSubresource.mipLevel,
                                         region->dstOffset.x,
                                         region->dstOffset.y,
                                         dstz,
-                                        src_image->planes[0].bo,
+                                        src_image->planes[src_plane].bo,
                                         region->srcSubresource.mipLevel,
                                         &src_box);
    }
diff --git a/src/gallium/frontends/lavapipe/lvp_image.c b/src/gallium/frontends/lavapipe/lvp_image.c
index 8dbcd28abd7..4d94ca8c164 100644
--- a/src/gallium/frontends/lavapipe/lvp_image.c
+++ b/src/gallium/frontends/lavapipe/lvp_image.c
@@ -663,6 +663,8 @@ lvp_CopyMemoryToImageEXT(VkDevice _device, const VkCopyMemoryToImageInfoEXT *pCo
    LVP_FROM_HANDLE(lvp_image, image, pCopyMemoryToImageInfo->dstImage);
    for (unsigned i = 0; i < pCopyMemoryToImageInfo->regionCount; i++) {
       const VkMemoryToImageCopyEXT *copy = &pCopyMemoryToImageInfo->pRegions[i];
+      const VkImageAspectFlagBits aspects = copy->imageSubresource.aspectMask;
+      uint8_t plane = lvp_image_aspects_to_plane(image, aspects);
       struct pipe_box box = {
          .x = copy->imageOffset.x,
          .y = copy->imageOffset.y,
@@ -670,7 +672,7 @@ lvp_CopyMemoryToImageEXT(VkDevice _device, const VkCopyMemoryToImageInfoEXT *pCo
          .height = copy->imageExtent.height,
          .depth = 1,
       };
-      switch (image->planes[0].bo->target) {
+      switch (image->planes[plane].bo->target) {
       case PIPE_TEXTURE_CUBE:
       case PIPE_TEXTURE_CUBE_ARRAY:
       case PIPE_TEXTURE_2D_ARRAY:
@@ -688,9 +690,9 @@ lvp_CopyMemoryToImageEXT(VkDevice _device, const VkCopyMemoryToImageInfoEXT *pCo
          break;
       }
 
-      unsigned stride = util_format_get_stride(image->planes[0].bo->format, copy->memoryRowLength ? copy->memoryRowLength : box.width);
-      unsigned layer_stride = util_format_get_2d_size(image->planes[0].bo->format, stride, copy->memoryImageHeight ? copy->memoryImageHeight : box.height);
-      device->queue.ctx->texture_subdata(device->queue.ctx, image->planes[0].bo, copy->imageSubresource.mipLevel, 0,
+      unsigned stride = util_format_get_stride(image->planes[plane].bo->format, copy->memoryRowLength ? copy->memoryRowLength : box.width);
+      unsigned layer_stride = util_format_get_2d_size(image->planes[plane].bo->format, stride, copy->memoryImageHeight ? copy->memoryImageHeight : box.height);
+      device->queue.ctx->texture_subdata(device->queue.ctx, image->planes[plane].bo, copy->imageSubresource.mipLevel, 0,
                                          &box, copy->pHostPointer, stride, layer_stride);
    }
    return VK_SUCCESS;
@@ -704,6 +706,10 @@ lvp_CopyImageToMemoryEXT(VkDevice _device, const VkCopyImageToMemoryInfoEXT *pCo
 
    for (unsigned i = 0; i < pCopyImageToMemoryInfo->regionCount; i++) {
       const VkImageToMemoryCopyEXT *copy = &pCopyImageToMemoryInfo->pRegions[i];
+
+      const VkImageAspectFlagBits aspects = copy->imageSubresource.aspectMask;
+      uint8_t plane = lvp_image_aspects_to_plane(image, aspects);
+
       struct pipe_box box = {
          .x = copy->imageOffset.x,
          .y = copy->imageOffset.y,
@@ -711,7 +717,7 @@ lvp_CopyImageToMemoryEXT(VkDevice _device, const VkCopyImageToMemoryInfoEXT *pCo
          .height = copy->imageExtent.height,
          .depth = 1,
       };
-      switch (image->planes[0].bo->target) {
+      switch (image->planes[plane].bo->target) {
       case PIPE_TEXTURE_CUBE:
       case PIPE_TEXTURE_CUBE_ARRAY:
       case PIPE_TEXTURE_2D_ARRAY:
@@ -729,14 +735,14 @@ lvp_CopyImageToMemoryEXT(VkDevice _device, const VkCopyImageToMemoryInfoEXT *pCo
          break;
       }
       struct pipe_transfer *xfer;
-      uint8_t *data = device->queue.ctx->texture_map(device->queue.ctx, image->planes[0].bo, copy->imageSubresource.mipLevel,
+      uint8_t *data = device->queue.ctx->texture_map(device->queue.ctx, image->planes[plane].bo, copy->imageSubresource.mipLevel,
                                                      PIPE_MAP_READ | PIPE_MAP_UNSYNCHRONIZED | PIPE_MAP_THREAD_SAFE, &box, &xfer);
       if (!data)
          return VK_ERROR_MEMORY_MAP_FAILED;
 
-      unsigned stride = util_format_get_stride(image->planes[0].bo->format, copy->memoryRowLength ? copy->memoryRowLength : box.width);
-      unsigned layer_stride = util_format_get_2d_size(image->planes[0].bo->format, stride, copy->memoryImageHeight ? copy->memoryImageHeight : box.height);
-      util_copy_box(copy->pHostPointer, image->planes[0].bo->format, stride, layer_stride,
+      unsigned stride = util_format_get_stride(image->planes[plane].bo->format, copy->memoryRowLength ? copy->memoryRowLength : box.width);
+      unsigned layer_stride = util_format_get_2d_size(image->planes[plane].bo->format, stride, copy->memoryImageHeight ? copy->memoryImageHeight : box.height);
+      util_copy_box(copy->pHostPointer, image->planes[plane].bo->format, stride, layer_stride,
                     /* offsets are all zero because texture_map handles the offset */
                     0, 0, 0, box.width, box.height, box.depth, data, xfer->stride, xfer->layer_stride, 0, 0, 0);
       pipe_texture_unmap(device->queue.ctx, xfer);
@@ -753,12 +759,18 @@ lvp_CopyImageToImageEXT(VkDevice _device, const VkCopyImageToImageInfoEXT *pCopy
 
    /* basically the same as handle_copy_image() */
    for (unsigned i = 0; i < pCopyImageToImageInfo->regionCount; i++) {
+
+      const VkImageAspectFlagBits src_aspects = pCopyImageToImageInfo->pRegions[i].srcSubresource.aspectMask;
+      uint8_t src_plane = lvp_image_aspects_to_plane(src_image, src_aspects);
+      const VkImageAspectFlagBits dst_aspects = pCopyImageToImageInfo->pRegions[i].dstSubresource.aspectMask;
+      uint8_t dst_plane = lvp_image_aspects_to_plane(dst_image, dst_aspects);
+
       struct pipe_box src_box;
       src_box.x = pCopyImageToImageInfo->pRegions[i].srcOffset.x;
       src_box.y = pCopyImageToImageInfo->pRegions[i].srcOffset.y;
       src_box.width = pCopyImageToImageInfo->pRegions[i].extent.width;
       src_box.height = pCopyImageToImageInfo->pRegions[i].extent.height;
-      if (src_image->planes[0].bo->target == PIPE_TEXTURE_3D) {
+      if (src_image->planes[src_plane].bo->target == PIPE_TEXTURE_3D) {
          src_box.depth = pCopyImageToImageInfo->pRegions[i].extent.depth;
          src_box.z = pCopyImageToImageInfo->pRegions[i].srcOffset.z;
       } else {
@@ -766,15 +778,15 @@ lvp_CopyImageToImageEXT(VkDevice _device, const VkCopyImageToImageInfoEXT *pCopy
          src_box.z = pCopyImageToImageInfo->pRegions[i].srcSubresource.baseArrayLayer;
       }
 
-      unsigned dstz = dst_image->planes[0].bo->target == PIPE_TEXTURE_3D ?
+      unsigned dstz = dst_image->planes[dst_plane].bo->target == PIPE_TEXTURE_3D ?
                       pCopyImageToImageInfo->pRegions[i].dstOffset.z :
                       pCopyImageToImageInfo->pRegions[i].dstSubresource.baseArrayLayer;
-      device->queue.ctx->resource_copy_region(device->queue.ctx, dst_image->planes[0].bo,
+      device->queue.ctx->resource_copy_region(device->queue.ctx, dst_image->planes[dst_plane].bo,
                                               pCopyImageToImageInfo->pRegions[i].dstSubresource.mipLevel,
                                               pCopyImageToImageInfo->pRegions[i].dstOffset.x,
                                               pCopyImageToImageInfo->pRegions[i].dstOffset.y,
                                               dstz,
-                                              src_image->planes[0].bo,
+                                              src_image->planes[src_plane].bo,
                                               pCopyImageToImageInfo->pRegions[i].srcSubresource.mipLevel,
                                               &src_box);
    }
-- 
2.42.0

