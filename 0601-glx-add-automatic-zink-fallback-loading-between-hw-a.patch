From 7d9ea77b4598e23d4415b529924f1cbdca6e33bd Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 9 Oct 2023 15:02:13 -0400
Subject: [PATCH 601/834] glx: add automatic zink fallback loading between hw
 and sw drivers

if loading the default hardware driver fails, implicitly loading zink
should now be preferable to hitting the software fallback now that zink
has all the same capabilities

Reviewed-by: Adam Jackson <ajax@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/25640>
---
 src/glx/glxext.c | 33 +++++++++++++++++++++++++--------
 1 file changed, 25 insertions(+), 8 deletions(-)

diff --git a/src/glx/glxext.c b/src/glx/glxext.c
index 324727379e2..42369e4da07 100644
--- a/src/glx/glxext.c
+++ b/src/glx/glxext.c
@@ -777,10 +777,11 @@ glx_screen_cleanup(struct glx_screen *psc)
 ** If that works then fetch the per screen configs data.
 */
 static Bool
-AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv)
+AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv, Bool zink)
 {
    struct glx_screen *psc;
    GLint i, screens;
+   unsigned screen_count = 0;
 
    /*
     ** First allocate memory for the array of per screen configs.
@@ -817,17 +818,21 @@ AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv)
       if (psc == NULL)
          psc = applegl_create_screen(i, priv);
 #else
-      if (psc == NULL)
+      if (psc == NULL && !zink)
       {
          psc = indirect_create_screen(i, priv);
          indirect = true;
       }
 #endif
       priv->screens[i] = psc;
+      if (psc)
+         screen_count++;
 
       if(indirect) /* Load extensions required only for indirect glx */
          glxSendClientInfo(priv, i);
    }
+   if (zink && !screen_count)
+      return GL_FALSE;
    SyncHandle();
    return GL_TRUE;
 }
@@ -889,9 +894,9 @@ __glXInitialize(Display * dpy)
 #if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
    Bool glx_direct = !debug_get_bool_option("LIBGL_ALWAYS_INDIRECT", false);
    Bool glx_accel = !debug_get_bool_option("LIBGL_ALWAYS_SOFTWARE", false);
-   Bool zink;
    const char *env = getenv("MESA_LOADER_DRIVER_OVERRIDE");
-   zink = env && !strcmp(env, "zink");
+   Bool zink = env && !strcmp(env, "zink");
+   Bool try_zink = False;
 
    dpyPriv->drawHash = __glxHashCreate();
 
@@ -913,10 +918,13 @@ __glXInitialize(Display * dpy)
 #endif /* HAVE_DRI3 */
       if (!debug_get_bool_option("LIBGL_DRI2_DISABLE", false))
          dpyPriv->dri2Display = dri2CreateDisplay(dpy);
+      if (!dpyPriv->dri3Display && !dpyPriv->dri2Display)
+         try_zink = !debug_get_bool_option("LIBGL_KOPPER_DISABLE", false) &&
+                    !getenv("GALLIUM_DRIVER");
    }
 #endif /* GLX_USE_DRM */
    if (glx_direct)
-      dpyPriv->driswDisplay = driswCreateDisplay(dpy, zink);
+      dpyPriv->driswDisplay = driswCreateDisplay(dpy, zink | try_zink);
 
 #ifdef GLX_USE_WINDOWSGL
    if (glx_direct && glx_accel)
@@ -931,9 +939,18 @@ __glXInitialize(Display * dpy)
    }
 #endif
 
-   if (!AllocAndFetchScreenConfigs(dpy, dpyPriv)) {
-      free(dpyPriv);
-      return NULL;
+   if (!AllocAndFetchScreenConfigs(dpy, dpyPriv, zink | try_zink)) {
+      Bool fail = True;
+      if (try_zink) {
+         free(dpyPriv->screens);
+         dpyPriv->driswDisplay->destroyDisplay(dpyPriv->driswDisplay);
+         dpyPriv->driswDisplay = driswCreateDisplay(dpy, false);
+         fail = !AllocAndFetchScreenConfigs(dpy, dpyPriv, False);
+      }
+      if (fail) {
+         free(dpyPriv);
+         return NULL;
+      }
    }
 
    glxSendClientInfo(dpyPriv, -1);
-- 
2.42.0

