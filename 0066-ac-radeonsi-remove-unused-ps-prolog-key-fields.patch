From 5263a9e364f5a401b1574006f259b5d1bbceba98 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 7 Aug 2023 15:18:12 +0800
Subject: [PATCH 066/834] ac,radeonsi: remove unused ps prolog key fields
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/24989>
---
 src/amd/common/ac_shader_util.c          | 44 ++++++++++--------------
 src/amd/common/ac_shader_util.h          |  3 +-
 src/amd/vulkan/radv_shader.c             |  2 +-
 src/gallium/drivers/radeonsi/si_shader.c | 10 ++----
 src/gallium/drivers/radeonsi/si_shader.h |  9 ++---
 5 files changed, 26 insertions(+), 42 deletions(-)

diff --git a/src/amd/common/ac_shader_util.c b/src/amd/common/ac_shader_util.c
index 26659eab8c1..6013eb5811f 100644
--- a/src/amd/common/ac_shader_util.c
+++ b/src/amd/common/ac_shader_util.c
@@ -620,14 +620,10 @@ enum ac_image_dim ac_get_image_dim(enum amd_gfx_level gfx_level, enum glsl_sampl
 }
 
 unsigned ac_get_fs_input_vgpr_cnt(const struct ac_shader_config *config,
-                                  signed char *face_vgpr_index_ptr,
-                                  signed char *ancillary_vgpr_index_ptr,
-                                  signed char *sample_coverage_vgpr_index_ptr)
+                                  uint8_t *num_pos_inputs)
 {
    unsigned num_input_vgprs = 0;
-   signed char face_vgpr_index = -1;
-   signed char ancillary_vgpr_index = -1;
-   signed char sample_coverage_vgpr_index = -1;
+   unsigned pos_inputs = 0;
 
    if (G_0286CC_PERSP_SAMPLE_ENA(config->spi_ps_input_addr))
       num_input_vgprs += 2;
@@ -645,35 +641,33 @@ unsigned ac_get_fs_input_vgpr_cnt(const struct ac_shader_config *config,
       num_input_vgprs += 2;
    if (G_0286CC_LINE_STIPPLE_TEX_ENA(config->spi_ps_input_addr))
       num_input_vgprs += 1;
-   if (G_0286CC_POS_X_FLOAT_ENA(config->spi_ps_input_addr))
+   if (G_0286CC_POS_X_FLOAT_ENA(config->spi_ps_input_addr)) {
       num_input_vgprs += 1;
-   if (G_0286CC_POS_Y_FLOAT_ENA(config->spi_ps_input_addr))
-      num_input_vgprs += 1;
-   if (G_0286CC_POS_Z_FLOAT_ENA(config->spi_ps_input_addr))
-      num_input_vgprs += 1;
-   if (G_0286CC_POS_W_FLOAT_ENA(config->spi_ps_input_addr))
-      num_input_vgprs += 1;
-   if (G_0286CC_FRONT_FACE_ENA(config->spi_ps_input_addr)) {
-      face_vgpr_index = num_input_vgprs;
+      pos_inputs++;
+   }
+   if (G_0286CC_POS_Y_FLOAT_ENA(config->spi_ps_input_addr)) {
       num_input_vgprs += 1;
+      pos_inputs++;
    }
-   if (G_0286CC_ANCILLARY_ENA(config->spi_ps_input_addr)) {
-      ancillary_vgpr_index = num_input_vgprs;
+   if (G_0286CC_POS_Z_FLOAT_ENA(config->spi_ps_input_addr)) {
       num_input_vgprs += 1;
+      pos_inputs++;
    }
-   if (G_0286CC_SAMPLE_COVERAGE_ENA(config->spi_ps_input_addr)) {
-      sample_coverage_vgpr_index = num_input_vgprs;
+   if (G_0286CC_POS_W_FLOAT_ENA(config->spi_ps_input_addr)) {
       num_input_vgprs += 1;
+      pos_inputs++;
    }
+   if (G_0286CC_FRONT_FACE_ENA(config->spi_ps_input_addr))
+      num_input_vgprs += 1;
+   if (G_0286CC_ANCILLARY_ENA(config->spi_ps_input_addr))
+      num_input_vgprs += 1;
+   if (G_0286CC_SAMPLE_COVERAGE_ENA(config->spi_ps_input_addr))
+      num_input_vgprs += 1;
    if (G_0286CC_POS_FIXED_PT_ENA(config->spi_ps_input_addr))
       num_input_vgprs += 1;
 
-   if (face_vgpr_index_ptr)
-      *face_vgpr_index_ptr = face_vgpr_index;
-   if (ancillary_vgpr_index_ptr)
-      *ancillary_vgpr_index_ptr = ancillary_vgpr_index;
-   if (sample_coverage_vgpr_index_ptr)
-      *sample_coverage_vgpr_index_ptr = sample_coverage_vgpr_index;
+   if (num_pos_inputs)
+      *num_pos_inputs = pos_inputs;
 
    return num_input_vgprs;
 }
diff --git a/src/amd/common/ac_shader_util.h b/src/amd/common/ac_shader_util.h
index 439a37ff9d9..e97cc0cddb4 100644
--- a/src/amd/common/ac_shader_util.h
+++ b/src/amd/common/ac_shader_util.h
@@ -170,8 +170,7 @@ enum ac_image_dim ac_get_image_dim(enum amd_gfx_level gfx_level, enum glsl_sampl
                                    bool is_array);
 
 unsigned ac_get_fs_input_vgpr_cnt(const struct ac_shader_config *config,
-                                  signed char *face_vgpr_index, signed char *ancillary_vgpr_index,
-                                  signed char *sample_coverage_vgpr_index_ptr);
+                                  uint8_t *num_pos_inputs);
 
 uint16_t ac_get_ps_iter_mask(unsigned ps_iter_samples);
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index b3bfda7f07d..a82d7a3b211 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1555,7 +1555,7 @@ radv_postprocess_binary_config(struct radv_device *device, struct radv_shader_bi
    unsigned num_input_vgprs = args->ac.num_vgprs_used;
 
    if (stage == MESA_SHADER_FRAGMENT) {
-      num_input_vgprs = ac_get_fs_input_vgpr_cnt(config, NULL, NULL, NULL);
+      num_input_vgprs = ac_get_fs_input_vgpr_cnt(config, NULL);
    }
 
    unsigned num_vgprs = MAX2(config->num_vgprs, num_input_vgprs);
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index bbafd08d26d..1ac482f2db7 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2906,8 +2906,7 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
    /* Calculate the number of fragment input VGPRs. */
    if (sel->stage == MESA_SHADER_FRAGMENT) {
       shader->info.num_input_vgprs = ac_get_fs_input_vgpr_cnt(
-         &shader->config, &shader->info.face_vgpr_index, &shader->info.ancillary_vgpr_index,
-         &shader->info.sample_coverage_vgpr_index);
+         &shader->config, &shader->info.num_ps_pos_inputs);
    }
 
    si_calculate_max_simd_waves(shader);
@@ -3099,7 +3098,6 @@ void si_get_ps_prolog_key(struct si_shader *shader, union si_shader_part_key *ke
    key->ps_prolog.wave32 = shader->wave_size == 32;
    key->ps_prolog.colors_read = info->colors_read;
    key->ps_prolog.num_input_sgprs = shader->info.num_input_sgprs;
-   key->ps_prolog.num_input_vgprs = shader->info.num_input_vgprs;
    key->ps_prolog.wqm =
       info->base.fs.needs_quad_helper_invocations &&
       (key->ps_prolog.colors_read || key->ps_prolog.states.force_persp_sample_interp ||
@@ -3107,8 +3105,7 @@ void si_get_ps_prolog_key(struct si_shader *shader, union si_shader_part_key *ke
        key->ps_prolog.states.force_persp_center_interp ||
        key->ps_prolog.states.force_linear_center_interp ||
        key->ps_prolog.states.bc_optimize_for_persp || key->ps_prolog.states.bc_optimize_for_linear);
-   key->ps_prolog.ancillary_vgpr_index = shader->info.ancillary_vgpr_index;
-   key->ps_prolog.sample_coverage_vgpr_index = shader->info.sample_coverage_vgpr_index;
+   key->ps_prolog.num_pos_inputs = shader->info.num_ps_pos_inputs;
 
    if (shader->key.ps.part.prolog.poly_stipple)
       shader->info.uses_vmem_load_other = true;
@@ -3119,7 +3116,6 @@ void si_get_ps_prolog_key(struct si_shader *shader, union si_shader_part_key *ke
       if (shader->key.ps.part.prolog.color_two_side) {
          /* BCOLORs are stored after the last input. */
          key->ps_prolog.num_interp_inputs = info->num_inputs;
-         key->ps_prolog.face_vgpr_index = shader->info.face_vgpr_index;
          shader->config.spi_ps_input_ena |= S_0286CC_FRONT_FACE_ENA(1);
       }
 
@@ -3688,7 +3684,7 @@ void si_get_ps_prolog_args(struct si_shader_args *args,
    /* skip LINE_STIPPLE_TEX */
 
    /* POS_X|Y|Z|W_FLOAT */
-   for (unsigned i = args->ac.num_vgprs_used; i < key->ps_prolog.face_vgpr_index; i++)
+   for (unsigned i = 0; i < key->ps_prolog.num_pos_inputs; i++)
       ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_FLOAT, NULL);
 
    ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_FLOAT, &args->ac.front_face);
diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index de5a669ce9b..e6b82e2fff1 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -675,13 +675,10 @@ union si_shader_part_key {
       struct si_ps_prolog_bits states;
       unsigned wave32 : 1;
       unsigned num_input_sgprs : 6;
-      unsigned num_input_vgprs : 5;
       /* Color interpolation and two-side color selection. */
       unsigned colors_read : 8;       /* color input components read */
       unsigned num_interp_inputs : 5; /* BCOLOR is at this location */
-      unsigned face_vgpr_index : 5;
-      unsigned ancillary_vgpr_index : 5;
-      unsigned sample_coverage_vgpr_index : 5;
+      unsigned num_pos_inputs : 3;
       unsigned wqm : 1;
       char color_attr_index[2];
       signed char color_interp_vgpr_index[2]; /* -1 == constant */
@@ -821,9 +818,7 @@ struct si_shader_binary_info {
    uint8_t num_input_vgprs;
    bool uses_vmem_load_other; /* all other VMEM loads and atomics with return */
    bool uses_vmem_sampler_or_bvh;
-   signed char face_vgpr_index;
-   signed char ancillary_vgpr_index;
-   signed char sample_coverage_vgpr_index;
+   uint8_t num_ps_pos_inputs;
    bool uses_instanceid;
    uint8_t nr_pos_exports;
    uint8_t nr_param_exports;
-- 
2.42.0

